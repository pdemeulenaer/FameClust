 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 !											    !
 !											    !
 !		FameClust 10.5                                                              !
 !		(Finding of Age Mass and Extinction of star Clusters)			    !
 !		Philippe de Meulenaer, PhD in Astrophysics                                  !
 !		Astronomical Observatory, Vilnius University				    !
 !											    !
 !											    !
 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 !
 ! Marie je te confie cela...
 !
 ! Date of conception: 28 January 2016
 ! Last update : 28 January 2016
 ! OLD Compilation : gfortran -O2 -march=native -mcmodel=medium Module_lecture.f90 FameClust_V105_observation.f90 -o FameClust_V105_observation.exe
 ! FASTER: gfortran -O3 -march=native -ffast-math -funroll-loops -mcmodel=medium Module_lecture.f90 FameClust_V105_observation.f90 -o FameClust_V105_observation.exe
 ! Compilation VHD : -mcmodel=large 
 ! Example: time ./FameClust_V105_observation.exe InputFameClustNEW_UBVRI_Z01900_M400 1 10 n00
 ! 
 !	   (No pain, no gain!)
 !         (Let's DO it!)
 !        O 
 !    ___o
 !   (*,*)
 !   (   )
 !---"--"----
 !
 !
 !!!!!!!!!!!!!!!!!!!!!!!!!!
 !IMPORTATIONS
 !!!!!!!!!!!!!!!!!!!!!!!!!!


 function smooth_gaussian_step_scalar(x, A, mu, sigma)
    ! '''This function is a step-like function: the left part of the step is a gaussian function with a given sigma. The right part of the step is 1. The idea is that the clusters models brighter than the mag-limit [mu] will be rejected from the probability computation: their probability computed using the other filters will be damped, multiplied by this step function, so by a factor close to 0. Cluster models fainter than the mag-limit will be kept (their computed proba will be multiplied by 1). The step is not abrupt, but gaussian to the bright (left) side, to take into account the uncertainty of the measurement of the mag-limit. '''

    real(4) :: smooth_gaussian_step_scalar
    real(4) :: x,A,mu,sigma

    !#Note: that step function takes scalar x and outputs scalar y.
    if (x < mu) then
     smooth_gaussian_step_scalar = A*exp(-(x-mu)**2/(2.*sigma**2))
    elseif (x>= mu) then
     smooth_gaussian_step_scalar = A
    else 
     write(*,*) 'ERROR!'
     write(*,*) 'mu = ', mu
     write(*,*) 'x = ', x
     read(*,*)
    endif
    return
 end function smooth_gaussian_step_scalar




 Program main
 use Lecture_module_fortran
 implicit none

 !!!!!!!!!!!!!!!!
 !INITIALISATIONS
 !!!!!!!!!!!!!!!!
 !integer, parameter :: N_bin_all_nodes = 7171000 !4331000 !5041000 !4331000 !5751000 !4331000 !106253000
 integer :: N_bin_all_nodes            != 7171000 !4331000 !5041000 !4331000 !5751000 !4331000 !106253000
 real(4), allocatable :: magnitude_GRID(:,:)
 real(4), allocatable :: age_list(:), mass_list(:), Ebv_list(:), sigma_obs_vector(:)
 real(4), allocatable :: age_max_chi2(:),mass_max_chi2(:),Ebv_max_chi2(:), chi2(:)
 real(4), allocatable :: A_lambda_filters_selected(:),M1_input(:,:),M1(:),M2(:),gaps_in_filter_GLOBAL(:,:)
 real(4), allocatable :: A_lambda_filters_selected_foreground(:) !For foreground extinction!!!
 real(4), allocatable :: M1_input_initial(:,:)
 real(4) :: chi2_min, chi2_min_old
 real(4) :: age, mass, Z, Ebv, age_maximal, mass_maximal, Z_maximal 
 real(4) :: distance_modulus
 !real(4) :: node_solution(1:71,1:101,1:121,1:9) !node_solution(650:1200,200:600,1:101,1:9)
 real(4), allocatable :: node_solution(:,:,:,:),GRID_read(:,:)
 real(4) :: lambda, lambda_f_MW, lambda_f_LMC,lambda_f_M31
 real(4) :: Probability_node,Probability_node_2,Probability_node_3,Probability_node_4
 real(4) :: data_input(1:52),data_sigma_input(1:52),xx
 real(4) :: Z_selected, Rv, index_real
 real(4), allocatable :: Grid_completed(:,:), M0(:,:), M1_M0(:,:),M2_M1(:),M0_prime(:,:), M1_M0_prime(:,:)
 real(4), allocatable :: d_direct_square(:),d_parallel_square(:)
 real(4), allocatable :: d_perpendicular_square(:),d_perpendicular(:)
 real(4), allocatable :: Ebv_vector(:), Grid_completed_selection(:,:)
 real(4), allocatable :: age_max_CG(:),mass_max_CG(:),Ebv_max_CG(:),Proba_max_CG(:)
 real(4), allocatable :: age_max_d2(:),mass_max_d2(:),Ebv_max_d2(:),Proba_max_d2(:)
 real(4), allocatable :: k(:), sigma_filter(:,:), sigma_filter_inverse(:,:) !General case
 real(4), allocatable :: sum_sigma_inverse_square(:), sum_sigma_inverse(:)
 real(4), allocatable :: sigma_filter_GLOBAL(:,:),sigma_filter_inverse_GLOBAL(:,:),gaps_in_filter(:,:)
 real(4), allocatable :: A_lambda_filters_selected_GLOBAL(:),M1_GLOBAL(:),M0_GLOBAL(:,:)
 real(4), allocatable :: sum_sigma_inverse_GLOBAL(:),sum_sigma_inverse_square_GLOBAL(:)
 real(4) :: Amplitude,xxx,mu,sigma_MagLim,MagLim_Factor,smooth_gaussian_step_scalar
 real(4) :: proba_model_oneFilter, Min_extinction, Max_extinction
 real(4) :: M2_M1_square, M2_M1_square_inverse
 real(4) :: sigma_magnitude,counting_inverse, proba_model, sigma_filter_automatic
 real(4) :: k_lower, k_higher, a_sigma, b_sigma, c_sigma, sigma_exp
 real(4) :: Rv_foreground, Ebv_foreground
 integer, allocatable :: M1_input_MagLim(:,:)
 integer, allocatable :: sigma1_total(:), sigma2_total(:), sigma3_total(:)
 integer, allocatable ::  filters_selected(:)
 integer, allocatable :: Cluster_ID(:),counting(:),OB_size(:), ID_models(:),nodata_all(:)
 integer(8) :: compteur
 integer :: sigma1_number, sigma2_number, sigma3_number
 integer :: Ext_limit1,Ext_limit2,filter_ID
 integer :: ff,ff_GLOBAL,hh,ii,jj,kk,ll,a,m,zz,Ext, number_cluster,n_lines,node
 integer :: list, number_cluster_observed
 integer :: multi_1,multi_2, method, choice, choice_extinction, weight
 integer :: number_filters,number_filters_GLOBAL, choice_filters, choice_extinction_law
 integer :: filters(1:52) !SHOULD BE IN ALLOCATABLE but conflict with input file reading
 integer :: idum, choice_noise, app_or_abs, switch, age_int, mass_int, aa,mm,zz_bis
 integer ::  number_begin, number_end, in_box, sigma_factor, choice_sigma
 integer :: max_proba_position(1:3)
 integer :: number_nodes_age,number_nodes_mass,number_models_per_node,number_of_filters_in_grid
 integer :: choice_RealClusters_or_ArtificialTest, choice_output_NodeFiles
 character(len=50) :: file_name,arg
 character(len=200) :: InputFile_Name
 character(len=50) :: age_indice,mass_indice,Z_indice,Ebv_indice,noise_flag,extinction_flag
 character(len=50) :: multi_char,jj_char, file_out_cluster2
 character(len=300) :: File_information_filters_and_ExtCurve
 character(len=300) :: file_out_cluster, file_out_cluster_f90, file_name_grid,file_Test_1000_random_clusters
 character(len=300) :: file_observed_clusters,forma, file_out_cluster_models
 character(len=300) :: file_out_cluster_node,file_out_cluster_histo
 character(len=300) :: file_name_nodes_bin,Grid_path,Grid_path1,Grid_path2
 CHARACTER(len=3) :: Z_indice_selected
 write(*,*)
 CALL system('date')

 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 !GETTING THE ARGUMENTS OF THE COMMAND-LINE 
 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 call getarg(1, InputFile_Name)
 InputFile_Name = '/home/philippe/Desktop/Discrete_models_comparaison_jtao&
	&/SC_Parameters_20/'//trim(adjustl(adjustr(InputFile_Name))) 
 call getarg(2, arg) 
 read (arg,'(I10)') number_begin
 call getarg(3, arg)
 read (arg,'(I10)') number_end
 call getarg(4, Z_indice_selected) 
 call age_mass_Z_December_Inverse(aa,mm,zz,Ext,age,mass,Z,Ebv, Z_indice_selected)
 call age_mass_Z_December(a,m,zz,Ext, age, mass, Z_selected, Ebv, age_indice, mass_indice, Z_indice, Ebv_indice)
 write(*,*)Z_indice,zz,Z_selected


 !# -------------------------
 !# Loading of the input file
 !# -------------------------
 filters(:) = 0
 open(unit=10,file=InputFile_Name)
 READ(10,*)
 READ(10,*)
 READ(10,*)number_filters_GLOBAL
 READ(10,*)
 allocate(filters_selected(1:number_filters_GLOBAL),A_lambda_filters_selected_GLOBAL(1:number_filters_GLOBAL))
 allocate(A_lambda_filters_selected_foreground(1:number_filters_GLOBAL)) !For foreground extinction!!!
 DO ii = 1,number_filters_GLOBAL
  READ(10,*) choice_filters
  filters_selected(ii)=choice_filters
  filters(choice_filters) = 1
 ENDDO
 READ(10,*)
 READ(10,*) distance_modulus  		!M33: 24.54 (McConnachie2004;2005) !M31: 24.47 (Narbutis2008)
 READ(10,*)
 READ(10,*) app_or_abs			!apparent or absolute magnitude? (1/2)
 READ(10,*)
 READ(10,*) file_observed_clusters	!name of the file containing the observed clusters
 READ(10,*)
 READ(10,*) number_cluster_observed	!How many clusters are there in your file
 READ(10,*)
 READ(10,*) choice_extinction		!cluster(s) studied extincted or not ? (1/2)
 READ(10,*)
 READ(10,*) choice_extinction_law
 READ(10,*)
 READ(10,'(a)') file_out_cluster  	!This format '(a)' because of the slashes in the name of directories
 READ(10,*)
 write(*,*) file_out_cluster		!Path where to store the output files
 READ(10,'(a)') Grid_path1
 READ(10,'(a)') Grid_path2
 READ(10,*)
 READ(10,*) number_nodes_age,number_nodes_mass
 READ(10,*)
 READ(10,*) number_models_per_node
 READ(10,*)
 READ(10,*) number_of_filters_in_grid
 READ(10,*)
 READ(10,'(a)') File_information_filters_and_ExtCurve
 READ(10,*)
 READ(10,*) Min_extinction, Max_extinction
 READ(10,*)
 READ(10,*) choice_RealClusters_or_ArtificialTest
 READ(10,*)
 READ(10,*) choice_output_NodeFiles
 close(10)



 !# -----------------------------------
 !# Allocations of the different tables
 !# -----------------------------------
 N_bin_all_nodes = number_nodes_age * number_nodes_mass * number_models_per_node !1000

 ALLOCATE(Cluster_ID(1:number_cluster_observed))
 ALLOCATE(Grid_completed(1:N_bin_all_nodes,1:4+number_filters_GLOBAL+2))
 ALLOCATE(M0_GLOBAL(1:N_bin_all_nodes,1:number_filters_GLOBAL))
 ALLOCATE(M1_input(1:number_cluster_observed,1:number_filters_GLOBAL))
 ALLOCATE(M1_input_initial(1:number_cluster_observed,1:number_filters_GLOBAL))
 !ALLOCATE(M1(1:number_filters),M2(1:number_filters))
 !ALLOCATE(M1_M0(1:N_bin_all_nodes,1:number_filters),M1_M0_prime(1:N_bin_all_nodes,1:number_filters))
 !ALLOCATE(M2_M1(1:number_filters))
 ALLOCATE(d_direct_square(1:N_bin_all_nodes))
 ALLOCATE(d_parallel_square(1:N_bin_all_nodes))
 ALLOCATE(d_perpendicular_square(1:N_bin_all_nodes))
 ALLOCATE(d_perpendicular(1:N_bin_all_nodes))
 ALLOCATE(Ebv_vector(1:N_bin_all_nodes))
 !ALLOCATE(Grid_completed_selection(1:5000000,1:4+number_filters_GLOBAL+2+number_filters_GLOBAL))
 !ALLOCATE(Grid_completed_selection(1:50000000,1:4+number_filters_GLOBAL+2+number_filters_GLOBAL))
 ALLOCATE(Grid_completed_selection(1:N_bin_all_nodes,1:4+number_filters_GLOBAL+2+number_filters_GLOBAL))
 ALLOCATE(age_max_CG(1:number_cluster_observed),mass_max_CG(1:number_cluster_observed))
 ALLOCATE(Ebv_max_CG(1:number_cluster_observed),Proba_max_CG(1:number_cluster_observed))
 ALLOCATE(age_max_d2(1:number_cluster_observed),mass_max_d2(1:number_cluster_observed))
 ALLOCATE(Ebv_max_d2(1:number_cluster_observed),Proba_max_d2(1:number_cluster_observed))
 ALLOCATE(k(1:N_bin_all_nodes),counting(1:number_cluster_observed))
 ALLOCATE(OB_size(1:number_cluster_observed))
 !ALLOCATE(sigma_filter(1:number_cluster_observed,1:number_filters))	!General case
 !ALLOCATE(sigma_filter_inverse(1:number_cluster_observed,1:number_filters))	!General case
 ALLOCATE(sum_sigma_inverse_square(1:number_cluster_observed))
 ALLOCATE(sum_sigma_inverse(1:number_cluster_observed))
 ALLOCATE(ID_models(1:N_bin_all_nodes))
 ALLOCATE(gaps_in_filter_GLOBAL(1:number_cluster_observed,1:number_filters_GLOBAL))
 ALLOCATE(nodata_all(1:number_cluster_observed))

 !For MagLim algorithm
 ALLOCATE(sigma_filter_GLOBAL(1:number_cluster_observed,1:number_filters_GLOBAL))	!General case
 ALLOCATE(sigma_filter_inverse_GLOBAL(1:number_cluster_observed,1:number_filters_GLOBAL))	!General case
 ALLOCATE(sum_sigma_inverse_square_GLOBAL(1:number_cluster_observed))
 ALLOCATE(sum_sigma_inverse_GLOBAL(1:number_cluster_observed))
 ALLOCATE(M1_input_MagLim(1:number_cluster_observed,1:number_filters_GLOBAL))

 ALLOCATE(node_solution(1:number_nodes_age,1:number_nodes_mass,1:121,1:9))
 ALLOCATE(GRID_read(1:number_models_per_node,1:number_of_filters_in_grid))



 !# -----------------------------------------------------------------------------------------
 !#Loading of the observations
 !# -----------------------------------------------------------------------------------------
 CALL chdir(file_out_cluster)
 file_observed_clusters = trim(file_observed_clusters) //'.fmct' !IT WILL READ THE .fmct FORMAT ONLY!!
 OPEN(unit=11,file=file_observed_clusters)
 READ(11,*)
 M1_input(:,:)=0.
 DO list = 1, number_cluster_observed
  !READ(11,*) Cluster_ID(list), xx,xx,xx,xx, data_input(1:52), xx,xx,xx,xx, &    !OLD <17Feb16!
  READ(11,*) Cluster_ID(list), xx,xx,xx,xx, data_input(1:52), &
       & data_sigma_input(1:52),M1_input_MagLim(list,1:number_filters_GLOBAL)
  do ff = 1,number_filters_GLOBAL   
   sigma_filter_GLOBAL(list,ff) = data_sigma_input(filters_selected(ff)) 
  enddo

  !if (list<10) write(*,*)M1_input_MagLim(list,1:number_filters_GLOBAL)

  do ff = 1,number_filters_GLOBAL  
   M1_input(list,ff) = data_input(filters_selected(ff))
   M1_input_initial(list,ff) = data_input(filters_selected(ff))
  enddo
  IF (app_or_abs == 1) then
   do ii = 1, number_filters_GLOBAL 
    !M1_input(ii,list) = M1_input(ii,list) - distance_modulus  !Careful, source of mistake with older code versions
    M1_input(list,ii) = M1_input(list,ii) - distance_modulus
   enddo
  ENDIF
 ENDDO
 CLOSE(11)

   

 !FOR GALEX: AB -> vega system!!! (GALEX in my grid is given in vega system)
 !DO ff = 1,number_filters_GLOBAL 
 ! if (filters_selected(ff)==1) M1_input_initial(:,ff) = M1_input_initial(:,ff) + 2.128
 ! if (filters_selected(ff)==2) M1_input_initial(:,ff) = M1_input_initial(:,ff) + 1.662 
 !ENDDO

 !FOR GALEX: ARTIFICIAL BRIGHTENING OF FUV AND NUV (test)
 !DO ff = 1,number_filters_GLOBAL 
 ! if (filters_selected(ff)==1) M1_input_initial(:,ff) = M1_input_initial(:,ff) -1.
 ! if (filters_selected(ff)==2) M1_input_initial(:,ff) = M1_input_initial(:,ff) -1.
 !ENDDO




 !Indication of the possible gaps in input data of observed clusters
 gaps_in_filter_GLOBAL(:,:) = 1
 DO list = 1, number_cluster_observed
  do ff=1,number_filters_GLOBAL 
   if (M1_input(list,ff) >= 30.) then
    gaps_in_filter_GLOBAL(list,ff) = 0
   endif
  enddo
 Enddo



 !# -----------------------------------------------------------------------------------------
 !#Loading of the A_lambda (extinction parameters) for the filters selected in the input file
 !# -----------------------------------------------------------------------------------------
 CALL chdir('/home/philippe/Desktop/Discrete_models_comparaison_jtao/SC_Parameters_20/Source/')
 open(unit=18, file = File_information_filters_and_ExtCurve)
 !open(unit=18, file = 'Filters_information.dat')
 !open(unit=18, file = 'Filters_information_observations.dat')
 !open(unit=18, file = 'Filters_information_observations_WFC3_from_STSCI.dat')
 !open(unit=18, file = 'Filters_information_observations_WFC3_from_STSCI_test.dat')
 read(18,*)
 jj=0
 do ii = 1,52 !46
  read(18,*)lambda, lambda_f_MW, lambda_f_LMC, lambda_f_M31, filter_ID, sigma_filter_automatic, xx, a_sigma, b_sigma, c_sigma
  if (filters(ii) == 1) then
   jj=jj+1
   if (choice_extinction_law == 1) then		!Case MW
    Rv = 3.1
    A_lambda_filters_selected_GLOBAL(jj)=lambda_f_MW
   elseif (choice_extinction_law == 2) then	!Case LMC average (Gordon 2003)
    Rv = 3.4
    A_lambda_filters_selected_GLOBAL(jj)=lambda_f_LMC
   elseif (choice_extinction_law == 3) then	!Case M31
    Rv = 2.5
    A_lambda_filters_selected_GLOBAL(jj)=lambda_f_M31
   endif

   A_lambda_filters_selected_foreground(jj)=lambda_f_MW !For the foreground MW extinction!!!

   do list = 1, number_cluster_observed
    if (gaps_in_filter_GLOBAL(list,jj) == 1) then  !only for the ones with data
     if (sigma_filter_GLOBAL(list,jj)<0.03) sigma_filter_GLOBAL(list,jj) = 0.03  	!Very low criteria  
     !if (sigma_filter_GLOBAL(list,jj)<0.05) sigma_filter_GLOBAL(list,jj) = 0.05  	!Classical criteria  
     !if (sigma_filter_GLOBAL(list,jj)<0.07) sigma_filter_GLOBAL(list,jj) = 0.07   	!large criteria 
     !sigma_filter_GLOBAL(list,jj) = sigma_filter_GLOBAL(list,jj) + 0.05 	        !additional uncertainty
    elseif (gaps_in_filter_GLOBAL(list,jj) == 0) then  !prevent gaps
     sigma_filter_GLOBAL(list,jj) = 9999. !1APRIL2016! before: 0.
    endif
   enddo


  endif
 enddo
 close(18)



 sum_sigma_inverse_GLOBAL(:)=0.
 sum_sigma_inverse_square_GLOBAL(:)=0.
 do list=1,10
  write(*,*)
  do ff=1,number_filters_GLOBAL
   write(*,*)ff,A_lambda_filters_selected_GLOBAL(ff),sigma_filter_GLOBAL(list,ff), M1_input_initial(list,ff)
   sigma_filter_inverse_GLOBAL(:,ff) = 1/sigma_filter_GLOBAL(:,ff)
  enddo
 enddo

 DO list = number_begin,number_end
  do ff=1,number_filters_GLOBAL
   if (gaps_in_filter_GLOBAL(list,ff)==1) then
    sum_sigma_inverse_square_GLOBAL(list) = sum_sigma_inverse_square_GLOBAL(list) + sigma_filter_inverse_GLOBAL(list,ff)
   endif
  enddo
 ENDDO
 sum_sigma_inverse_GLOBAL(:) = sum_sigma_inverse_square_GLOBAL(:)**0.5

 !write(*,*) 'sum_sigma_inverse_GLOBAL(1):', sum_sigma_inverse_GLOBAL(1)
 !read(*,*)




 !# ----------------------------------------------
 !# Loading of the grid of models (from .bin file)
 !# ----------------------------------------------
 CALL chdir('/home/philippe/Desktop/Discrete_models_comparaison_jtao/SC_Parameters_20/Source/')
 Grid_completed(:,:) = 0.
 CALL system('date')
 WRITE(*,*) '' 
 WRITE(*,*) ' Loading of the grid in the program'
 Grid_path = trim(Grid_path1) // trim(Z_indice) // trim(Grid_path2) 
 ii=1
 Do aa = 1,number_nodes_age   !71  		   !Loop on the age. 
  Do mm = 1,number_nodes_mass !101 ![2.7-5.0] !81  !Loop on the mass.  
    Ext = 1
    call age_mass_Z_December(aa,mm,zz,Ext,age,mass,Z,Ebv,age_indice,mass_indice,Z_indice,Ebv_indice)
    file_name_nodes_bin = trim(Grid_path) // 't' // trim(age_indice) // '_M' //&
	& trim(mass_indice) // '_Z' // trim(Z_indice)
    !call Lecture_UBVRI_ugriz_GRID_Jan2013(file_name_nodes_bin) 
    call Lecture_GRID_March2016(file_name_nodes_bin,GRID_READ,number_models_per_node) 
    do ff=1,number_filters_GLOBAL 
     Grid_completed(ii:ii+number_models_per_node-1,4+ff) = GRID_READ(:,filters_selected(ff))
    enddo
    Grid_completed(ii:ii+number_models_per_node-1,1) = age
    Grid_completed(ii:ii+number_models_per_node-1,2) = log10(mass)
    Grid_completed(ii:ii+number_models_per_node-1,4) = Z
    ii=ii+number_models_per_node
  Enddo
  write(*,*)age
 Enddo
 do ff=1,number_filters_GLOBAL 
  M0_GLOBAL(:,ff) = Grid_completed(:,4+ff) 
 enddo


 !write(*,*) 'M0_GLOBAL:', M0_GLOBAL(1,:)
 !write(*,*) 'M0_GLOBAL:', M0_GLOBAL(2,:)
 !write(*,*) 'M0_GLOBAL:', M0_GLOBAL(3,:)
 !write(*,*)
 !read(*,*)
 
 
 WRITE(*,*) ' The grid has been loaded correctly, from: ', file_name_nodes_bin 
 WRITE(*,*) '' 
 CALL system('date')

  




 !# -------------------------------------------------------
 !# Preparation of the extinction (foreground used or not?)
 !# -------------------------------------------------------

 Ebv_foreground = 0.06 !mag. If 0, no foreground extinction adopted
 Rv_foreground  = 3.1  !As the standard value for the MW (using CCM 1989)

 do list = number_begin,number_end
  !De-reddening of the observation by the foreground extinction
  M1_input(list,:) = M1_input(list,:) - A_lambda_filters_selected_foreground * Rv_foreground * Ebv_foreground
 enddo

 !FOR M31
 !k_lower  = 0.02 	!Ebv_foreground=0.04 == k_higher = 0.02	!M31
 !k_lower  = 0.03 	!Ebv_foreground=0.06 == k_higher = 0.03	!M31  !as in Fouesneau 2014, using Schlegel value, E(B-V)=0.062
 !k_higher = 0.55 !0.5 	!Ebv_limit = 1.0 == k_higher = 0.5	!M31   if 1. -> Ebv_limit = 2.

 !FOR M33
 !k_lower  = 0.02 	!Ebv_foreground=0.04 == k_higher = 0.02	!M31
 !k_lower  = 0.03 	!Ebv_foreground=0.06 == k_higher = 0.03	!M31  !as in Fouesneau 2014, using Schlegel value, E(B-V)=0.062
 !k_higher = 0.50 !0.15 !for Ebvlimit=0.30 !0.5 	!Ebv_limit = 1.0 == k_higher = 0.5	!M31   if 1. -> Ebv_limit = 2.

 !k_lower  = 0.0 	!Ebv_foreground=0.06 == k_higher = 0.03	!M31  !as in Fouesneau 2014, using Schlegel value, E(B-V)=0.062
 !k_higher = 0.50 !0.15 !for Ebvlimit=0.30 !0.5 	!Ebv_limit = 1.0 == k_higher = 0.5	!M31   if 1. -> Ebv_limit = 2.

 !k_lower  = 0.5*Min_extinction	
 k_lower  = 0.   !IN CASE OF FOREGROUND EXTINCTION ENABLED!
 k_higher = 0.5*Max_extinction

 !just to check the foreground-dereddened photometry
 do list=1,10
  write(*,*)
  do ff=1,number_filters_GLOBAL
   write(*,*)ff,M1_input_initial(list,ff) - distance_modulus, M1_input(list,ff)
  enddo
 enddo
 !read(*,*)





 sum_sigma_inverse(:) = 0.
 sum_sigma_inverse_square(:) = 0.

 DO list = number_begin,number_end
	
	!# ------------------------------------------------------------------------
	!# UPDATING ARRAYS TO TAKE MagLim INTO ACCOUNT
	!# ------------------------------------------------------------------------
        !# Arrays needing to be updated (create local versions of global arrays): 
        !# - M1
        !# - M0, M0_prime, M1_M0_prime
        !# - k
        !# - A_lambda_filters_selected 
        !# - sigma_filter, sigma_filter_inverse, sum_sigma_inverse
        !# - Grid_completed ???, Grid_completed_selection ??? NO!

        !Here I need to know how many filters there will be, number_filters
        ff=0                                                 !#V105
	do ff_GLOBAL=1,number_filters_GLOBAL                 !#V105
         if (M1_input_MagLim(list,ff_GLOBAL) == 1) then !mask[ff_GLOBAL]:  #proba built using filters with exact measurements, not Mag limits
          ff=ff+1  !In python we use after this ff_index = max(0,ff-1)  !#V105                           
         endif
        enddo
        number_filters = ff  !#The new number of filters available for this particular cluster
        !write(*,*)'number_filters= ',number_filters

        !Them we can allocate the arrays
        ALLOCATE(M0(1:N_bin_all_nodes,1:number_filters),M0_prime(1:N_bin_all_nodes,1:number_filters))
        ALLOCATE(M1(1:number_filters),M2(1:number_filters))
        ALLOCATE(M1_M0(1:N_bin_all_nodes,1:number_filters),M1_M0_prime(1:N_bin_all_nodes,1:number_filters))
        ALLOCATE(M2_M1(1:number_filters))
        ALLOCATE(A_lambda_filters_selected(1:number_filters))
        ALLOCATE(sigma_filter(1:number_cluster_observed,1:number_filters))	!General case
        ALLOCATE(sigma_filter_inverse(1:number_cluster_observed,1:number_filters))	!General case
        ALLOCATE(gaps_in_filter(1:number_cluster_observed,1:number_filters))

        ff=0                                                 !#V105
	do ff_GLOBAL=1,number_filters_GLOBAL                 !#V105
         if (M1_input_MagLim(list,ff_GLOBAL) == 1) then !mask[ff_GLOBAL]:  #proba built using filters with exact measurements, not Mag limits
          ff=ff+1  !In python we use after this ff_index = max(0,ff-1)  !#V105      

          gaps_in_filter(list,ff) = gaps_in_filter_GLOBAL(list,ff_GLOBAL)

          M1(ff) = M1_input(list,ff_GLOBAL)                  !#V105
          A_lambda_filters_selected(ff) = A_lambda_filters_selected_GLOBAL(ff_GLOBAL)    !#V105
          sigma_filter(list,ff) = sigma_filter_GLOBAL(list,ff_GLOBAL)
          sigma_filter_inverse(list,ff) = sigma_filter_inverse_GLOBAL(list,ff_GLOBAL)
          sum_sigma_inverse_square(list) = sum_sigma_inverse_square(list) + sigma_filter_inverse(list,ff)        
	  M0(:,ff) = M0_GLOBAL(:,ff_GLOBAL)                  !#V105
         endif
        enddo

        sum_sigma_inverse(list) = sum_sigma_inverse_square(list)**0.5

        !write(*,*)sigma_filter(list,:)
        !write(*,*)sigma_filter_inverse(list,:)
        !write(*,*)sum_sigma_inverse_square(list),sum_sigma_inverse(list)
        !write(*,*)
	!write(*,*) 'M0:', M0(1,:)
	!write(*,*) 'M0:', M0(2,:)
	!write(*,*) 'M0:', M0(3,:)
        !write(*,*)

        !write(*,*) 'FLAG 0.8'

	!# ------------------------------------------------------------------------
	!# Reddening of the observation, to obtain the line going through M1 and M2
	!# ------------------------------------------------------------------------
	!M1(:) = M1_input(list,:)                      !We take the observation from the list of observed clusters:
	M2 = M1 - A_lambda_filters_selected * Rv*2    !We deredden observation by a quantity E(B-V)=2, to have the line (M2,M1)

	!write(*,*) 'M1:', M1(:)
	!write(*,*) 'M2:', M2(:)
	!write(*,*)

	!# ----------------------------------------------------------
	!# Derivation of the distances d_perpendicular and d_parallel
	!# ----------------------------------------------------------
        do ff=1,number_filters
	 M1_M0(:,ff) = ( M1(ff) - M0(:,ff) ) * sigma_filter_inverse(list,ff)/sum_sigma_inverse(list)
         if (gaps_in_filter(list,ff)==0) then
	  M1_M0(:,ff) = 0.
	 endif
        enddo

	M2_M1 = (M2(:)-M1(:)) * sigma_filter_inverse(list,:)/sum_sigma_inverse(list)
        do ff=1,number_filters
         if (gaps_in_filter(list,ff)==0) then
	  M2_M1(ff) = 0.
	 endif
	enddo

	!write(*,*) 'M1_M0:', M1_M0(1,:)
	!write(*,*) 'M1_M0:', M1_M0(2,:)
	!write(*,*) 'M1_M0:', M1_M0(3,:)
        !write(*,*)
	!write(*,*) 'M2_M1:', M2_M1(:)
        !write(*,*)
        !read(*,*)

	d_direct_square(:) = 0.
	do ff=1,number_filters
	 d_direct_square(:) = d_direct_square(:) + M1_M0(:,ff)*M1_M0(:,ff)
	enddo

	M2_M1_square = 0.
	do ff=1,number_filters
	 M2_M1_square = M2_M1_square + M2_M1(ff)*M2_M1(ff)
	enddo
	M2_M1_square_inverse = M2_M1_square**(-1)

	!#IF WE WANT THE k FACTOR!!!
	k(:)=0.
	do ff=1,number_filters
	 k(:) = k(:) - M1_M0(:,ff)*M2_M1(ff)
	enddo
	k=k*M2_M1_square_inverse
	d_parallel_square = k*k*M2_M1_square

	!write(*,*) 'k(1):', k(1)
	!write(*,*) 'k(2):', k(2)
	!write(*,*) 'k(N_bin_all_nodes):', k(N_bin_all_nodes)
	!write(*,*)
	!read(*,*)


	d_perpendicular_square = d_direct_square - d_parallel_square
	Ebv_vector = 2*(d_parallel_square*M2_M1_square_inverse)**0.5	
	 
        do ff=1,number_filters  !Now we want to compute the reddening of the M0 points, to get the M0' ones.
	 M0_prime(:,ff) = M0(:,ff) + A_lambda_filters_selected(ff) * Rv*Ebv_vector(:)
        enddo
	
	!Now we want to get the distances between M0' and the M1 point (i.e. the coordinates of M0' in the system of M1).  
        do ff=1,number_filters
	 M1_M0_prime(:,ff) = abs(M0_prime(:,ff) - M1(ff))
         if (gaps_in_filter(list,ff)==0) then
	  M1_M0_prime(:,ff) = 0.
	 endif
        enddo

	!write(*,*) 'M1_M0_prime(1,:):', M1_M0_prime(1,:)
	!write(*,*) 'M1_M0_prime(2,:):', M1_M0_prime(2,:)
	!write(*,*) 'M1_M0_prime(N_bin_all_nodes,:):', M1_M0_prime(N_bin_all_nodes,:)
	!write(*,*)
	!read(*,*)

        !write(*,*) 'FLAG 0.9'


	!# -----------------------------
	!# Selection of models in the OB
	!# -----------------------------
	!#Traditional OB
	counting(list) = 0
	OB_size(list) = 3
	sigma_factor = 3	!Indicates the size of the OB, in sigma units
	ID_models(:) = 0
 
        Grid_completed_selection(:,:)=0.

	!If we want to explore all the models of the grid
	!counting(list) = N_bin_all_nodes
	!OB_size(list) = 7 !Means all nodes
	!If we want to explore an OB in place of all the models of the grid
	do 

	 !!!! HERE IT COULD BE THAT I SHOULD PUT counting(list) = 0 : if the OB> 3, it should be
	 !!!! reinitialized, because we cannot take 2 times one model which was also in OB=3!!!!
 
	 do ii = 1,N_bin_all_nodes
	  in_box=0 !1
	 
	  !HERE PUT THE K FACTOR SELECTION,TO EXCLUDE MODELS OUT OF E(B-V)=[0,1], out of [0,k_max]
	  if (k(ii) >= k_lower .and. k(ii)<k_higher) then		!k is in unit of E(B-V) = 2! 
	   !do ff = 1,number_filters
	   ! if (gaps_in_filter_GLOBAL(list,ff)==1) then 
	   !  if (M1_M0_prime(ii,ff)<sigma_factor*sigma_filter(list,ff)) then	!General case
           !  !if (abs(M1_M0(ii,ff))<sigma_factor*sigma_filter(list,ff)) then	!IF WE DO NOT WANT EXTINCTION!!!!!!!
	   !   in_box=1
	   !  else
	   !   in_box=0
	   !   exit
 	   !  endif
	   ! else
           !  in_box=1
	   ! endif
	   !enddo
    in_box=1  !!!!!!!!!!!!INFINITE OB SIZE!!!!!!!!!!!!!!!! (means that we remove the OB, take all models of all nodes!!!)
	  endif
	
	  if (k_lower == 0.) then
	   if (k(ii) < 0) then	!In that case we look if M0 ITSELF is in OB
	    do ff = 1,number_filters
	     if (gaps_in_filter(list,ff)==1) then
	      if (abs(M1_M0(ii,ff))<sigma_factor*sigma_filter(list,ff)) then		!General case
	       in_box=1
	      else
	       in_box=0
	       exit
 	      endif
	     else
              in_box=1
	     endif
	    enddo
	   endif
	  endif


        !write(*,*) 'FLAG 1, ii=', ii
        !read(*,*)

	  
	  if (in_box==1) then
	     counting(list) = counting(list) + 1
	     ID_models(counting(list)) = ii
	     Grid_completed_selection(counting(list),:) = Grid_completed(ii,:)
	     if (k(ii) >= 0 .and. k(ii)<k_higher) then	!Classical case
	     !if (k(ii) >= 0) then	!Case for inspection of the whole grid 
	      !Grid_completed_selection(counting(list),3) = Ebv_vector(ii) ! 2*(d_parallel_square(ii)*M2_M1_square_inverse)**0.5
	      Grid_completed_selection(counting(list),3) = Ebv_vector(ii) + Ebv_foreground !ADDING FOREGROUND EXTINCTION!!!
	     else                       !Case where k<0. --> M0 is in OB, no extinction.
	      !Grid_completed_selection(counting(list),3) = 0. !sign(Ebv_vector(ii),k(ii))
	      Grid_completed_selection(counting(list),3) = 0. + Ebv_foreground !ADDING FOREGROUND EXTINCTION!!!
	     endif
	     Grid_completed_selection(counting(list),4+number_filters_GLOBAL+1) = d_perpendicular_square(ii) !**0.5
	     Grid_completed_selection(counting(list),4+number_filters_GLOBAL+2) = d_perpendicular_square(ii)**(-1)

        !write(*,*) 'FLAG 1.1, ii=', ii
        !write(*,*)
        !read(*,*)

	     !Here copy of M1_M0_prime into Grid_completed_selection
	     ff=0                                                 !#V105
	     do ff_GLOBAL=1,number_filters_GLOBAL                 !#V105
              if (M1_input_MagLim(list,ff_GLOBAL) == 1) then !proba built using filters with exact measurements, not Mag limits
               ff=ff+1  !In python we use after this ff_index = max(0,ff-1)  !#V105
	       Grid_completed_selection(counting(list),4+number_filters_GLOBAL+2+1:4+number_filters_GLOBAL+2+number_filters) = &
	       &    + M1_M0_prime(ii,1:number_filters) !V105       
	      endif
	     enddo

	  endif
	 enddo


	 if (counting(list) > number_models_per_node) then
	  exit
	 elseif (sigma_factor >= 6) then	!We do not explore further than 6 sigmas from observation
	  exit
	 else
	  sigma_factor = sigma_factor + 1
	  OB_size(list) = OB_size(list) +1
	 endif
	enddo


	counting_inverse = (counting(list)*1.)**(-1)
	write(*,*) 'Cluster', list, 'ID =', Cluster_ID(list), ' #in OB',counting(list), 'OB =', OB_size(list)

	!write(*,*)'Ebv_vector(1)',Ebv_vector(1)
	!write(*,*)

	!write(*,*) 'Grid_completed_selection(1,:):', Grid_completed_selection(1,:)
	!write(*,*)
	!write(*,*) 'Grid_completed_selection(2,:):', Grid_completed_selection(2,:)
	!write(*,*)
	!write(*,*) 'Grid_completed_selection(counting(list),:):', Grid_completed_selection(counting(list),:)
	!write(*,*)
        !read(*,*)


        !write(*,*) 'FLAG 1.1'

	!# ------------------------------------
	!# Building the probabilities 
	!# ------------------------------------

	!Writing of final solution 
	node_solution = 0.
	Proba_max_CG(list) = 0.
	Proba_max_d2(list) = 0.

	do ii = 1,counting(list)
         !age_int = nint(Grid_completed_selection(ii,1)*100)
         !mass_int = nint(Grid_completed_selection(ii,2)*100)
	 aa  = nint(20*(Grid_completed_selection(ii,1)-6.60)+1)
	 mm  = nint(20*(Grid_completed_selection(ii,2)-2.00)+1)
	 !Ext = nint(50*Grid_completed_selection(ii,3)) + 1
	 Ext = nint(50*max(Grid_completed_selection(ii,3),0.)) + 1  !NOTE: MAX NOT PRESENT IN SIMPLE V101 VERSION
	 !Ext = nint(100*Grid_completed_selection(ii,3)) + 1      !HERE BE CAREFULL!! IS IT 100 OR 50?????


	 !ALTERNATIVE CASE WITH PART 1/sqrt(2pi)sigma before proba (sqrt(2pi) not useful)  (V105) 
         !In fact it gives (almost) the same results as without 1/sqrt(2pi)sigma (not the same probabilities, but same parameters, see also FameClust_V105.f90)
	 !proba_model_vector(:)=0.
	 proba_model=1.
         ff=0  
	 do ff_GLOBAL = 1,number_filters_GLOBAL
          proba_model_oneFilter=0.
          if (M1_input_MagLim(list,ff_GLOBAL) == 1) then !mask[ff_GLOBAL]:  #proba built using filters with exact measurements, not Mag limits
           ff=ff+1

	   if (gaps_in_filter(list,ff)==1) then
	    proba_model_oneFilter = &
	& + ( Grid_completed_selection(ii,4+number_filters_GLOBAL+2+ff) * sigma_filter_inverse_GLOBAL(list,ff_GLOBAL) )**2	!General case
	    proba_model_oneFilter = sigma_filter_inverse_GLOBAL(list,ff_GLOBAL) * exp(-0.5*proba_model_oneFilter)
	    proba_model=proba_model*proba_model_oneFilter
           endif

          endif
 	 enddo


         !# HERE USE THE STEP-FUNCTION!!!! Multiply the proba of the model by its associated step-function   #V105
         MagLim_Factor = 1.                                    !# Initialization of the magnitude-limit factor 
	 do ff_GLOBAL=1,number_filters_GLOBAL     !# For each filter we test:  
          if (gaps_in_filter_GLOBAL(list,ff_GLOBAL)==1) then   !If not gap    
           if (M1_input_MagLim(list,ff_GLOBAL) == 0) then ! not 1! HERE only for filters concerned by the magnitude-limit algorithm

            !# the ORIGINAL mag of the model...it should be REDDENED by the Ebv derived!
            xxx = Grid_completed_selection(ii,4+ff_GLOBAL) !identical to M0_GLOBAL[selection,ff_GLOBAL][ii]            
            xxx = xxx + A_lambda_filters_selected_GLOBAL(ff_GLOBAL) * Rv * Grid_completed_selection(ii,3) !# the mag reddened

            Amplitude=1.               !# the max of the step function (1.)
            sigma_MagLim=sigma_filter_GLOBAL(list,ff_GLOBAL)   !# the sigma of the gaussian part of the step function 
            !mu=M1_input(list,ff_GLOBAL)  -  1.         !# the magnitude-limit measured   (IF - 1 IT MEANS TESTS OF THE ALGO!!!)
            mu=M1_input(list,ff_GLOBAL)  -  3.*sigma_MagLim    !# the magnitude-limit measured   (IF - 3*sigma IT MEANS TESTS OF THE ALGO!!!)
            MagLim_Factor = MagLim_Factor * smooth_gaussian_step_scalar(xxx, Amplitude, mu, sigma_MagLim) !# building of the magnitude-limit factor
           endif
          endif
         enddo

	 node_solution(aa,mm,Ext,1) = node_solution(aa,mm,Ext,1) &
	& + proba_model * counting_inverse !* MagLim_Factor  !no Prior  (V105)

	 if (node_solution(aa,mm,Ext,1) > Proba_max_CG(list) ) then !.and. Ext < 52) then
	  age_max_CG(list) = Grid_completed_selection(ii,1)
	  mass_max_CG(list) = Grid_completed_selection(ii,2)
	  Ebv_max_CG(list) = Grid_completed_selection(ii,3)
	  Proba_max_CG(list) = node_solution(aa,mm,Ext,1)
	 endif

	enddo

        !write(*,*) 'FLAG 1.2'


	!max_proba_position = MAXLOC(node_solution(:,:,:,1)) !It gives the position (aa,mm,Ext) of the max 
	!write(*,*) max_proba_position

	!# ----------------------------------------------
	!Writing of node file for each individual cluster  (takes a bit more time)
	!# ----------------------------------------------
        if (choice_output_NodeFiles == 1) then
	 WRITE(jj_char, '(i10)' ) Cluster_ID(list)
	 file_out_cluster_node=trim(file_out_cluster)//'node_files_F105/'
	 OPEN(unit = 40,file=trim(file_out_cluster_node)//'Cluster_'//trim(adjustl(jj_char))//'_node_Z'//Z_indice_selected//'.dat')
	 write(40,*)' #aa  mm  Ext  Proba'
 	 do aa = 1,number_nodes_age   !71 !650, 1200
 	  do mm = 1,number_nodes_mass !101 !200, 600
 	   do Ext = 1,121 !Ext_limit1,Ext_limit2
	    if (node_solution(aa,mm,Ext,1) > 0.) then
 	     write(40,'(i4,i4,i4,E12.3)') & !write(40,'(i4,i4,i4,E12.3,E12.3,i4)') &
	 & aa,mm, Ext, &
	 & node_solution(aa,mm,Ext,1) 
	    endif
 	   enddo
 	  enddo
 	 enddo
 	 close(40)
        endif

	
	!Option: output the ID and parameters of models located in the OB. Slows down the code... 
        !WRITE(jj_char, '(i10)' ) Cluster_ID(list)	
	!file_out_cluster_models=trim(file_out_cluster)//'models_files/'
	!OPEN(unit = 41,file=trim(file_out_cluster_models)//'Cluster_'//trim(adjustl(jj_char))//'_Z'//Z_indice_selected//'_V101_models.dat')
	!do ii = 1,counting(list)
        ! if (nint(Grid_completed_selection(ii,1)*100) ==  nint(age_max_CG(list)*100) ) then
        !  if (nint(Grid_completed_selection(ii,2)*100) == nint(mass_max_CG(list)*100) ) then
        !   if (nint(50*Grid_completed_selection(ii,3))  == nint(50*Ebv_max_CG(list)) ) then
	!    write(41,*)ID_models(ii), mod (ID_models(ii), 1000), Grid_completed_selection(ii,1), &
	!& Grid_completed_selection(ii,2), Grid_completed_selection(ii,3)
	!   endif
	!  endif
	! endif
	!enddo
 	!close(41)



        !write(*,*) 'FLAG 2'

        deALLOCATE(M0,M0_prime,M1,M2,M1_M0,M1_M0_prime,M2_M1)
        deALLOCATE(A_lambda_filters_selected)
        deALLOCATE(sigma_filter,sigma_filter_inverse,gaps_in_filter)	


 ENDDO



 !# ----------------------------------------------
 !Writing of solutions for all clusters (for 1Z)
 !# ----------------------------------------------
 file_out_cluster_f90 = trim(file_out_cluster)
 file_out_cluster = trim(file_out_cluster)//'file_out_cluster'
 file_out_cluster_f90 = trim(file_out_cluster_f90)//'All_clusters_parameters_results_f90_V105'
 file_out_cluster_f90 = trim(file_out_cluster_f90)//'_Z'//Z_indice_selected
 open(unit=41,file=file_out_cluster_f90)
 write(41,*)'# ID   age3 mas3 Ebv3  Proba3         count    OB'
 do list = number_begin,number_end
  write(41,'(i5,F7.2,F5.2,F5.2,E12.4,i10,i5)') &
	& Cluster_ID(list), &
	& age_max_CG(list),mass_max_CG(list),Ebv_max_CG(list),Proba_max_CG(list), &
	& counting(list), OB_size(list)
 enddo
 close(41)


 CALL system('date')
 WRITE(*,*)' Computation completed' 

 deALLOCATE(Cluster_ID)
 deALLOCATE(Grid_completed)
 deALLOCATE(M0_GLOBAL)
 deALLOCATE(M1_input)
 deALLOCATE(M1_input_initial)
 deALLOCATE(d_direct_square)
 deALLOCATE(d_parallel_square)
 deALLOCATE(d_perpendicular_square)
 deALLOCATE(d_perpendicular)
 deALLOCATE(Ebv_vector)
 deALLOCATE(Grid_completed_selection)
 deALLOCATE(age_max_CG,mass_max_CG)
 deALLOCATE(Ebv_max_CG,Proba_max_CG)
 deALLOCATE(age_max_d2,mass_max_d2)
 deALLOCATE(Ebv_max_d2,Proba_max_d2)
 deALLOCATE(k,counting)
 deALLOCATE(OB_size)
 deALLOCATE(sum_sigma_inverse_square)
 deALLOCATE(sum_sigma_inverse)
 deALLOCATE(ID_models)
 deALLOCATE(gaps_in_filter_GLOBAL)
 deALLOCATE(nodata_all)
 !For MagLim algorithm
 deALLOCATE(sigma_filter_GLOBAL)	!General case
 deALLOCATE(sigma_filter_inverse_GLOBAL)	!General case
 deALLOCATE(sum_sigma_inverse_square_GLOBAL)
 deALLOCATE(sum_sigma_inverse_GLOBAL)
 deALLOCATE(M1_input_MagLim)


 
 end program
