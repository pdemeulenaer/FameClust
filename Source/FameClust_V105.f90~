 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 !											    !
 !											    !
 !		FameClust 10.5                                                              !
 !		(Finding of Age Mass and Extinction of star Clusters)			    !
 !		Philippe de Meulenaer, PhD in Astrophysics                                  !
 !		Astronomical Observatory, Vilnius University				    !
 !											    !
 !											    !
 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 !
 ! Marie je te confie cela...
 !
 ! Date of conception: 27 January 2016
 ! Last update : 27 January 2016
 ! OLD Compilation : gfortran -O2 -march=native -mcmodel=medium Module_lecture.f90 FameClust_V105.f90 -o FameClust_V105.exe
 ! FASTER: gfortran -O3 -march=native -ffast-math -funroll-loops -mcmodel=medium Module_lecture.f90 FameClust_V105.f90 -o FameClust_V105.exe
 ! Compilation VHD : -mcmodel=large 
 ! Example: time ./FameClust_V105.exe InputFameClustNEW_UBVRI_Z01900_M400 1 10 n00
 ! 
 !	   (No pain, no gain!)
 !         (Let's DO it!)
 !        O 
 !    ___o
 !   (*,*)
 !   (   )
 !---"--"----
 !
 !
 !!!!!!!!!!!!!!!!!!!!!!!!!!
 !IMPORTATIONS
 !!!!!!!!!!!!!!!!!!!!!!!!!!


 function smooth_gaussian_step_scalar(x, A, mu, sigma)
    ! '''This function is a step-like function: the left part of the step is a gaussian function with a given sigma. The right part of the step is 1. The idea is that the clusters models brighter than the mag-limit [mu] will be rejected from the probability computation: their probability computed using the other filters will be damped, multiplied by this step function, so by a factor close to 0. Cluster models fainter than the mag-limit will be kept (their computed proba will be multiplied by 1). The step is not abrupt, but gaussian to the bright (left) side, to take into account the uncertainty of the measurement of the mag-limit. '''

    real(4) :: smooth_gaussian_step_scalar
    real(4) :: x,A,mu,sigma

    !#Note: that step function takes scalar x and outputs scalar y.
    if (x < mu) then
     smooth_gaussian_step_scalar = A*exp(-(x-mu)**2/(2.*sigma**2))
    elseif (x>= mu) then
     smooth_gaussian_step_scalar = A
    else 
     write(*,*) 'ERROR!'
     write(*,*) 'mu = ', mu
     write(*,*) 'x = ', x
     read(*,*)
    endif
    return
 end function smooth_gaussian_step_scalar




 Program main
 use Lecture_module_fortran
 implicit none

 !!!!!!!!!!!!!!!!
 !INITIALISATIONS
 !!!!!!!!!!!!!!!!
 integer, parameter :: N_bin_all_nodes = 7171000 !4331000 !5041000 !4331000 !5751000 !4331000 !106253000
 real(4), allocatable :: magnitude_GRID(:,:)
 real(4), allocatable :: age_list(:), mass_list(:), Ebv_list(:), sigma_obs_vector(:)
 real(4), allocatable :: age_max_chi2(:),mass_max_chi2(:),Ebv_max_chi2(:), chi2(:)
 real(4), allocatable :: A_lambda_filters_selected(:),M1_input(:,:),M1(:),M2(:)
 real(4), allocatable :: M1_input_initial(:,:)
 real(4) :: chi2_min, chi2_min_old
 real(4) :: age, mass, Z, Ebv, age_maximal, mass_maximal, Z_maximal 
 real(4) :: distance_modulus
 real(4) :: node_solution(1:71,1:101,1:121,1:9) !node_solution(650:1200,200:600,1:101,1:9)
 real(4) :: lambda, lambda_f_MW, lambda_f_LMC
 real(4) :: Probability_node,Probability_node_2,Probability_node_3,Probability_node_4
 real(4) :: GRID_read(1:1000,1:52),data_input(1:52),xx
 real(4) :: Z_selected, Rv, index_real
 real(4), allocatable :: Grid_completed(:,:), M0(:,:), M1_M0(:,:),M2_M1(:),M0_prime(:,:), M1_M0_prime(:,:)
 real(4), allocatable :: d_direct_square(:),d_parallel_square(:)
 real(4), allocatable :: d_perpendicular_square(:),d_perpendicular(:)
 real(4), allocatable :: Ebv_vector(:), Grid_completed_selection(:,:)
 real(4), allocatable :: age_max_CG(:),mass_max_CG(:),Ebv_max_CG(:),Proba_max_CG(:)
 real(4), allocatable :: age_max_d2(:),mass_max_d2(:),Ebv_max_d2(:),Proba_max_d2(:)
 real(4), allocatable :: k(:), sigma_filter(:,:), sigma_filter_inverse(:,:) !General case
 real(4), allocatable :: sum_sigma_inverse_square(:), sum_sigma_inverse(:)

 real(4), allocatable :: sigma_filter_GLOBAL(:,:),sigma_filter_inverse_GLOBAL(:,:)
 real(4), allocatable :: A_lambda_filters_selected_GLOBAL(:),M1_GLOBAL(:),M0_GLOBAL(:,:)
 real(4), allocatable :: sum_sigma_inverse_GLOBAL(:),sum_sigma_inverse_square_GLOBAL(:)
 real(4) :: Amplitude,xxx,mu,sigma,MagLim_Factor,smooth_gaussian_step_scalar

 real(4) :: M2_M1_square, M2_M1_square_inverse
 real(4) :: sigma_magnitude,counting_inverse, proba_model, sigma_filter_automatic
 real(4) :: histo_age(1:101), histo_mass(1:101), histo_Ebv(1:101), histo_Z(1:101)

 integer, allocatable :: M1_input_MagLim(:,:)

 integer, allocatable :: sigma1_total(:), sigma2_total(:), sigma3_total(:)
 integer, allocatable ::  filters_selected(:), at_least_one_model_in_OB_array(:,:,:)
 integer, allocatable :: Cluster_ID(:),counting(:),OB_size(:), ID_models(:)
 integer(8) :: compteur
 integer :: sigma1_number, sigma2_number, sigma3_number,at_least_one_model_in_OB
 integer :: Ext_limit1,Ext_limit2,filter_ID
 integer :: ff,ff_GLOBAL,hh,ii,jj,kk,ll,a,m,zz,Ext, number_cluster,n_lines,node
 integer :: list, number_cluster_observed
 integer :: multi_1,multi_2, method, choice, choice_extinction, weight
 integer :: number_filters,number_filters_GLOBAL, choice_filters, filters(1:52), choice_extinction_law
 integer :: idum, choice_noise, app_or_abs, switch, age_int, mass_int, aa,mm,zz_bis
 integer ::  number_begin, number_end, in_box, sigma_factor, choice_sigma
 character(len=50) :: file_name,arg
 character(len=200) :: InputFile_Name
 character(len=50) :: age_indice,mass_indice,Z_indice,Ebv_indice,noise_flag,extinction_flag
 character(len=50) :: extinction_file_name
 character(len=50) :: multi_char,jj_char, file_out_cluster2
 character(len=300) :: file_out_cluster, file_out_cluster_f90, file_name_grid,file_Test_1000_random_clusters
 character(len=300) :: file_observed_clusters,file_name_nodes_bin,forma
 character(len=300) :: file_out_cluster_node,file_out_cluster_histo
 CHARACTER(len=3) :: Z_indice_selected
 write(*,*)
 CALL system('date')

 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 !GETTING THE ARGUMENTS OF THE COMMAND-LINE 
 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 call getarg(1, InputFile_Name)
 InputFile_Name = '/home/philippe/Desktop/Discrete_models_comparaison_jtao&
	&/SC_Parameters_20/'//trim(adjustl(adjustr(InputFile_Name)))
 call getarg(2, arg) 
 read (arg,'(I10)') number_begin
 call getarg(3, arg)
 read (arg,'(I10)') number_end
 call getarg(4, Z_indice_selected) 
 call age_mass_Z_December_Inverse(aa,mm,zz,Ext,age,mass,Z,Ebv, Z_indice_selected)
 call age_mass_Z_December(a,m,zz,Ext, age, mass, Z_selected, Ebv, age_indice, mass_indice, Z_indice, Ebv_indice)
 write(*,*)Z_indice,zz,Z_selected


 !# -------------------------
 !# Loading of the input file
 !# -------------------------
 filters(:) = 0
 open(unit=10,file=InputFile_Name)
 READ(10,*)
 READ(10,*)
 READ(10,*)number_filters_GLOBAL
 READ(10,*)
 allocate(filters_selected(1:number_filters_GLOBAL),A_lambda_filters_selected_GLOBAL(1:number_filters_GLOBAL))
 DO ii = 1,number_filters_GLOBAL
  READ(10,*) choice_filters
  filters_selected(ii)=choice_filters
  filters(choice_filters) = 1
 ENDDO
 READ(10,*)
 READ(10,*) distance_modulus  		!M33: 24.54 (McConnachie2004;2005) !M31: 24.47 (Narbutis2008)
 READ(10,*)
 READ(10,*) app_or_abs			!apparent or absolute magnitude? (1/2)
 READ(10,*)
 READ(10,*) file_observed_clusters	!name of the file containing the observed clusters
 READ(10,*)
 READ(10,*) number_cluster_observed	!How many clusters are there in your file
 READ(10,*)
 READ(10,*) choice_extinction		!cluster(s) studied extincted or not ? (1/2)
 READ(10,*)
 READ(10,*) choice_extinction_law
 READ(10,*)
 !READ(10,*) choice_sigma		!Automatic sigma (1) input file sigma (2)
 !READ(10,*)
 READ(10,'(a)') file_out_cluster  	!This format '(a)' because of the slashes in the name of directories
 write(*,*) file_out_cluster		!Path where to store the output files
 close(10)


 !# -----------------------------------
 !# Allocations of the different tables
 !# -----------------------------------
 ALLOCATE(Cluster_ID(1:number_cluster_observed))
 ALLOCATE(Grid_completed(1:N_bin_all_nodes,1:4+number_filters_GLOBAL+2))
 ALLOCATE(M0_GLOBAL(1:N_bin_all_nodes,1:number_filters_GLOBAL))
 ALLOCATE(M1_input(1:number_filters_GLOBAL,1:number_cluster_observed))
 !ALLOCATE(M0(1:N_bin_all_nodes,1:number_filters),M0_prime(1:N_bin_all_nodes,1:number_filters))
 !ALLOCATE(M1(1:number_filters),M2(1:number_filters))
 !ALLOCATE(M1_M0(1:N_bin_all_nodes,1:number_filters),M1_M0_prime(1:N_bin_all_nodes,1:number_filters))
 !ALLOCATE(M2_M1(1:number_filters))
 ALLOCATE(d_direct_square(1:N_bin_all_nodes))
 ALLOCATE(d_parallel_square(1:N_bin_all_nodes))
 ALLOCATE(d_perpendicular_square(1:N_bin_all_nodes))
 ALLOCATE(d_perpendicular(1:N_bin_all_nodes))
 ALLOCATE(Ebv_vector(1:N_bin_all_nodes))
 !ALLOCATE(Grid_completed_selection(1:5000000,1:4+number_filters_GLOBAL+2+number_filters_GLOBAL))
 ALLOCATE(Grid_completed_selection(1:50000000,1:4+number_filters_GLOBAL+2+number_filters_GLOBAL))
 ALLOCATE(age_max_CG(1:number_cluster_observed),mass_max_CG(1:number_cluster_observed))
 ALLOCATE(Ebv_max_CG(1:number_cluster_observed),Proba_max_CG(1:number_cluster_observed))
 ALLOCATE(age_max_d2(1:number_cluster_observed),mass_max_d2(1:number_cluster_observed))
 ALLOCATE(Ebv_max_d2(1:number_cluster_observed),Proba_max_d2(1:number_cluster_observed))
 ALLOCATE(k(1:N_bin_all_nodes),counting(1:number_cluster_observed))
 ALLOCATE(OB_size(1:number_cluster_observed))
 !ALLOCATE(sigma_filter(1:number_cluster_observed,1:number_filters))	!General case
 !ALLOCATE(sigma_filter_inverse(1:number_cluster_observed,1:number_filters))	!General case
 ALLOCATE(sum_sigma_inverse_square(1:number_cluster_observed))
 ALLOCATE(sum_sigma_inverse(1:number_cluster_observed))
 ALLOCATE(ID_models(1:N_bin_all_nodes))

 !For MagLim algorithm
 ALLOCATE(sigma_filter_GLOBAL(1:number_cluster_observed,1:number_filters_GLOBAL))	!General case
 ALLOCATE(sigma_filter_inverse_GLOBAL(1:number_cluster_observed,1:number_filters_GLOBAL))	!General case
 ALLOCATE(sum_sigma_inverse_square_GLOBAL(1:number_cluster_observed))
 ALLOCATE(sum_sigma_inverse_GLOBAL(1:number_cluster_observed))
 ALLOCATE(M1_input_MagLim(1:number_cluster_observed,1:number_filters_GLOBAL))
 

 !# -----------------------------------------------------------------------------------------
 !#Loading of the observations
 !# -----------------------------------------------------------------------------------------
 CALL chdir(file_out_cluster)
 OPEN(unit=11,file=file_observed_clusters)
 READ(11,*)
 M1_input(:,:)=0.
 DO list = 1, number_cluster_observed
  READ(11,*) index_real, xx,xx,xx,xx, data_input(1:52),M1_input_MagLim(list,1:number_filters_GLOBAL)
  !if (list<10) write(*,*)M1_input_MagLim(list,1:number_filters_GLOBAL)
  Cluster_ID(list) = nint(index_real)
  do ff = 1,number_filters_GLOBAL   
   M1_input(ff,list) = data_input(filters_selected(ff))
  enddo
  !write(*,*) Cluster_ID(list), M1_input(1:number_filters_GLOBAL,list)
  IF (app_or_abs == 1) then
   do ii = 1, number_filters_GLOBAL
    M1_input(ii,list) = M1_input(ii,list) - distance_modulus
   enddo
  ENDIF
 ENDDO
 CLOSE(11)




 !# -----------------------------------------------------------------------------------------
 !#Loading of the A_lambda (extinction parameters) for the filters selected in the input file
 !# -----------------------------------------------------------------------------------------
 CALL chdir('/home/philippe/Desktop/Discrete_models_comparaison_jtao/SC_Parameters_20/Source/')
 open(unit=18, file = 'Filters_information.dat')
 !open(unit=18, file = 'Filters_information_observations.dat')
 !open(unit=18, file = 'Filters_information_observations_WFC3_from_STSCI.dat')
 !open(unit=18, file = 'Filters_information_observations_WFC3_from_STSCI_test.dat')
 read(18,*)
 jj=0
 do ii = 1,52 !46
  read(18,*)lambda, lambda_f_MW, lambda_f_LMC, filter_ID, sigma_filter_automatic
  if (filters(ii) == 1) then
   jj=jj+1
   if (choice_extinction_law == 1) then		!Case MW
    Rv = 3.1
    A_lambda_filters_selected_GLOBAL(jj)=lambda_f_MW
   elseif (choice_extinction_law == 2) then	!Case LMC average (Gordon 2003)
    Rv = 3.4
    A_lambda_filters_selected_GLOBAL(jj)=lambda_f_LMC
   elseif (choice_extinction_law == 3) then	!Case M31
    Rv = 2.5
    A_lambda_filters_selected_GLOBAL(jj)=lambda_f_M31
   endif
   sigma_filter_GLOBAL(:,jj) = sigma_filter_automatic
  endif
 enddo
 close(18)

 sum_sigma_inverse_GLOBAL(:)=0.
 sum_sigma_inverse_square_GLOBAL(:)=0.
 do ff=1,number_filters_GLOBAL
  write(*,*)ff,A_lambda_filters_selected_GLOBAL(ff),sigma_filter_GLOBAL(1,ff)
  sigma_filter_inverse_GLOBAL(:,ff) = 1/sigma_filter_GLOBAL(:,ff)
  sum_sigma_inverse_square_GLOBAL(:) = sum_sigma_inverse_square_GLOBAL(:) + sigma_filter_inverse_GLOBAL(:,ff)
 enddo
 sum_sigma_inverse_GLOBAL(:) = sum_sigma_inverse_square_GLOBAL(:)**0.5

 !write(*,*) 'sum_sigma_inverse_GLOBAL(1):', sum_sigma_inverse_GLOBAL(1)
 !read(*,*)



 
 

 !# ----------------------------------------------
 !# Loading of the grid of models (from .bin file)
 !# ----------------------------------------------
 CALL chdir('/home/philippe/Desktop/Discrete_models_comparaison_jtao/SC_Parameters_20/Source/')
 Grid_completed(:,:) = 0.
 CALL system('date')
 WRITE(*,*) '' 
 WRITE(*,*) ' Loading of the grid in the program'
 ii=1
 allocate(at_least_one_model_in_OB_array(1:71,1:71,1:101)) !(1:71,1:101,1:101))
 Do aa = 1,71  		!Loop on the age. 
  Do mm = 1,101 ![2.7-5.0] !81  !Loop on the mass. 
 !Do aa = 1,353  		!Loop on the age. 
 ! Do mm = 1,301 ![2.7-5.0] !401 !Loop on the mass. 
    Ext = 1
    call age_mass_Z_December(aa,mm,zz,Ext,age,mass,Z,Ebv,age_indice,mass_indice,Z_indice,Ebv_indice)

    !FRS Grid gCMD
    !file_name_nodes_bin = '/home/philippe/Desktop/Discrete_models_comparaison_jtao/Grid_gCMD014_71_81_Z'
    !file_name_nodes_bin = trim(file_name_nodes_bin) // trim(Z_indice) // '_AllB_HST_20pc_untruncated_iso_binary/'
    !file_name_nodes_bin=trim(file_name_nodes_bin)//trim(Z_indice)//'_AllB_HST_20pc_untruncated_iso_Kr02CB_binary/'
    !file_name_nodes_bin=trim(file_name_nodes_bin)//trim(Z_indice)//'_AllB_HST_20pc_untruncated_iso_Kr01NCB_binary/'
    !file_name_nodes_bin = trim(file_name_nodes_bin) // trim(Z_indice) // '_AllB_HST_20pc_untruncated_iso_VHD_binary/'
    !file_name_nodes_bin = '/mnt/storage2/philippe/Grid_gCMD014_71_81_Z'
    !file_name_nodes_bin = trim(file_name_nodes_bin) // trim(Z_indice) // '_AllB_HST_20pc_untruncated_iso_binary/'

    !FRS Grid
    file_name_nodes_bin = '/home/philippe/Desktop/Discrete_models_comparaison_jtao/Grids_with_ACS/Grid_FRS_Z'              !TRADITIONAL
    file_name_nodes_bin = trim(file_name_nodes_bin) // trim(Z_indice) // '_Kroupa_1000models_per_node_with_ACS_binary/'
    !!file_name_nodes_bin = '/home/philippe/Desktop/Discrete_models_comparaison_jtao/Grids_with_ACS_noMassiveStar/Grid_FRS_Z' !NO MASSIVE STARS
    !!file_name_nodes_bin = trim(file_name_nodes_bin) // trim(Z_indice) // '_Kroupa_1000models_per_node_with_ACS_binary/'

    !file_name_nodes_bin = '/home/philippe/Desktop/Discrete_models_comparaison_jtao/Grid_Z'              !TRADITIONAL
    !file_name_nodes_bin = trim(file_name_nodes_bin) // trim(Z_indice) // '_test2_binary/'



    !file_name_nodes_bin = '/home/philippe/Desktop/Discrete_models_comparaison_jtao/Grid_Z'
    !file_name_nodes_bin = trim(file_name_nodes_bin) //adjustl(trim(Z_indice))//'_from_npzGMM_binary/'

    !HRS Grid!
    !file_name_nodes_bin = '/mnt/storage/philippe/Grid_HRS_Z'
    !file_name_nodes_bin = '/home/philippe/Desktop/Discrete_models_comparaison_jtao/Grid_HRS_Z'
    !file_name_nodes_bin = '/opt/Grid_HRS_Z'
    !file_name_nodes_bin = trim(file_name_nodes_bin) // trim(Z_indice) // '_ExpFactor6_Kroupa_binary/'
    !file_name_nodes_bin = trim(file_name_nodes_bin) // trim(Z_indice) // '_ExpFactor6_Weidner_corrected_binary/'
    !file_name_nodes_bin = '/mnt/storage/philippe/Grids_Interpolated_Age_Mass/Grid_HRS_Z'
    !file_name_nodes_bin = trim(file_name_nodes_bin) // trim(Z_indice) // '_ExpFactor6_Weidner_corrected_interpolated_binary/'
    !file_name_nodes_bin = '/mnt/storage/philippe/Grids_increased_nodes_sizes_mean_rule_80pc_fit/Grid_HRS_Z'
    !file_name_nodes_bin = trim(file_name_nodes_bin) // trim(Z_indice) // '_ExpFactor6_Weidner_corrected_NodesIncreased_binary/'

    !file_name_nodes_bin = '/mnt/storage/philippe/Grid_HRS_allZ_ExpFactor6_Weidner_corrected_NPZ/GRID_NPZ/Grid_HRS_Z'
    !file_name_nodes_bin = trim(file_name_nodes_bin) // trim(Z_indice) // '_ExpFactor6_Weidner_corrected_binary/'
    !file_name_nodes_bin = '/mnt/storage/philippe/Grid_HRS_allZ_ExpFactor6_Weidner_corrected_NPZ/'
    !file_name_nodes_bin = trim(file_name_nodes_bin) // 'GRID_NPZ_with_same_node_size_Zm12/Grid_HRS_Z'
    !file_name_nodes_bin = trim(file_name_nodes_bin) // trim(Z_indice) // '_ExpFactor6_Weidner_corrected_binary/'


    !SSP grid!!
    !file_name_nodes_bin = '/home/philippe/Desktop/Discrete_models_comparaison_jtao/Grid_SSP_CMD25/Grid_SSP_Z'
    !file_name_nodes_bin = trim(file_name_nodes_bin) // trim(Z_indice) // '_nonoise_binary/'

    file_name_nodes_bin = trim(file_name_nodes_bin) // 't' // trim(age_indice) // '_M' //&
	& trim(mass_indice) // '_Z' // trim(Z_indice)
    call Lecture_UBVRI_ugriz_GRID_Jan2013(file_name_nodes_bin,GRID_READ) 
    do ff=1,number_filters_GLOBAL 
     Grid_completed(ii:ii+999,4+ff) = GRID_READ(:,filters_selected(ff))
    enddo
    Grid_completed(ii:ii+999,1) = age
    Grid_completed(ii:ii+999,2) = log10(mass)
    Grid_completed(ii:ii+999,4) = Z
    ii=ii+1000
  Enddo
  write(*,*)age
 Enddo
 do ff=1,number_filters_GLOBAL 
  M0_GLOBAL(:,ff) = Grid_completed(:,4+ff) 
 enddo


 !write(*,*) 'M0_GLOBAL:', M0_GLOBAL(1,:)
 !write(*,*) 'M0_GLOBAL:', M0_GLOBAL(2,:)
 !write(*,*) 'M0_GLOBAL:', M0_GLOBAL(3,:)
 !write(*,*)
 !read(*,*)

 WRITE(*,*) ' The grid has been loaded correctly' 
 WRITE(*,*) '' 
 CALL system('date')

 sum_sigma_inverse(:) = 0.
 sum_sigma_inverse_square(:) = 0.

 DO list = number_begin,number_end
	at_least_one_model_in_OB_array(:,:,:) = 0. !Reinitialization

	!# ------------------------------------------------------------------------
	!# UPDATING ARRAYS TO TAKE MagLim INTO ACCOUNT
	!# ------------------------------------------------------------------------
        !# Arrays needing to be updated (create local versions of global arrays): 
        !# - M1
        !# - M0, M0_prime, M1_M0_prime
        !# - k
        !# - A_lambda_filters_selected 
        !# - sigma_filter, sigma_filter_inverse, sum_sigma_inverse
        !# - Grid_completed ???, Grid_completed_selection ??? NO!

        !Here I need to know how many filters there will be, number_filters
        ff=0                                                 !#V105
	do ff_GLOBAL=1,number_filters_GLOBAL                 !#V105
         if (M1_input_MagLim(list,ff_GLOBAL) == 1) then !mask[ff_GLOBAL]:  #proba built using filters with exact measurements, not Mag limits
          ff=ff+1  !In python we use after this ff_index = max(0,ff-1) #V105                           
         endif
        enddo
        number_filters = ff  !#The new number of filters available for this particular cluster
        !write(*,*)'number_filters= ',number_filters

        !Them we can allocate the arrays
        ALLOCATE(M0(1:N_bin_all_nodes,1:number_filters),M0_prime(1:N_bin_all_nodes,1:number_filters))
        ALLOCATE(M1(1:number_filters),M2(1:number_filters))
        ALLOCATE(M1_M0(1:N_bin_all_nodes,1:number_filters),M1_M0_prime(1:N_bin_all_nodes,1:number_filters))
        ALLOCATE(M2_M1(1:number_filters))
        ALLOCATE(A_lambda_filters_selected(1:number_filters))
        ALLOCATE(sigma_filter(1:number_cluster_observed,1:number_filters))	!General case
        ALLOCATE(sigma_filter_inverse(1:number_cluster_observed,1:number_filters))	!General case

        ff=0                                                 !#V105
	do ff_GLOBAL=1,number_filters_GLOBAL                 !#V105
         if (M1_input_MagLim(list,ff_GLOBAL) == 1) then !mask[ff_GLOBAL]:  #proba built using filters with exact measurements, not Mag limits
          ff=ff+1  !In python we use after this ff_index = max(0,ff-1)  !#V105      

          M1(ff) = M1_input(ff_GLOBAL,list)                  !#V105
          A_lambda_filters_selected(ff) = A_lambda_filters_selected_GLOBAL(ff_GLOBAL)    !#V105
          sigma_filter(list,ff) = sigma_filter_GLOBAL(list,ff_GLOBAL)
          sigma_filter_inverse(list,ff) = sigma_filter_inverse_GLOBAL(list,ff_GLOBAL)
          sum_sigma_inverse_square(list) = sum_sigma_inverse_square(list) + sigma_filter_inverse(list,ff)        
	  M0(:,ff) = M0_GLOBAL(:,ff_GLOBAL)                  !#V105
         endif
        enddo

        sum_sigma_inverse(list) = sum_sigma_inverse_square(list)**0.5

        !write(*,*)sigma_filter(list,:)
        !write(*,*)sigma_filter_inverse(list,:)
        !write(*,*)sum_sigma_inverse_square(list),sum_sigma_inverse(list)
        !write(*,*)
	!write(*,*) 'M0:', M0(1,:)
	!write(*,*) 'M0:', M0(2,:)
	!write(*,*) 'M0:', M0(3,:)
        !write(*,*)
        

	!# ------------------------------------------------------------------------
	!# Reddening of the observation, to obtain the line going through M1 and M2
	!# ------------------------------------------------------------------------
	!M1(:) = M1_input(:,list)                     !V101 !We take the observation from the list of observed clusters:
	M2 = M1 - A_lambda_filters_selected * Rv*2    !We deredden observation by a quantity E(B-V)=2, to have the line (M2,M1)

	!write(*,*) 'M1:', M1(:)
	!write(*,*) 'M2:', M2(:)
	!write(*,*)

	!# ----------------------------------------------------------
	!# Derivation of the distances d_perpendicular and d_parallel
	!# ----------------------------------------------------------
        !do ff=1,number_filters_GLOBAL  !V101 loop
	! M1_M0(:,ff) = ( M1(ff) - M0(:,ff) ) * sigma_filter_inverse_GLOBAL(list,ff)/sum_sigma_inverse_GLOBAL(list)
        !enddo
        do ff=1,number_filters  !V105 loop
	 M1_M0(:,ff) = ( M1(ff) - M0(:,ff) ) * sigma_filter_inverse(list,ff)/sum_sigma_inverse(list)
        enddo

	!M2_M1 = (M2(:)-M1(:)) * sigma_filter_inverse_GLOBAL(list,:)/sum_sigma_inverse_GLOBAL(list)  !V101
	M2_M1 = (M2(:)-M1(:)) * sigma_filter_inverse(list,:)/sum_sigma_inverse(list)  !V105

	!write(*,*) 'M1_M0:', M1_M0(1,:)
	!write(*,*) 'M1_M0:', M1_M0(2,:)
	!write(*,*) 'M1_M0:', M1_M0(3,:)
        !write(*,*)
	!write(*,*) 'M2_M1:', M2_M1(:)
        !write(*,*)
        !read(*,*)

	d_direct_square(:) = 0.
	do ff=1,number_filters
	 d_direct_square(:) = d_direct_square(:) + M1_M0(:,ff)*M1_M0(:,ff)
	enddo

	M2_M1_square = 0.
	do ff=1,number_filters
	 M2_M1_square = M2_M1_square + M2_M1(ff)*M2_M1(ff)
	enddo
	M2_M1_square_inverse = M2_M1_square**(-1)

	!#IF WE WANT THE k FACTOR!!!
	k(:)=0.
	do ff=1,number_filters
	 k(:) = k(:) - M1_M0(:,ff)*M2_M1(ff)
	enddo
	k=k*M2_M1_square_inverse
	d_parallel_square = k*k*M2_M1_square

	!write(*,*) 'k(1):', k(1)
	!write(*,*) 'k(2):', k(2)
	!write(*,*) 'k(N_bin_all_nodes):', k(N_bin_all_nodes)
	!write(*,*)
	!read(*,*)


	d_perpendicular_square = d_direct_square - d_parallel_square
	Ebv_vector = 2*(d_parallel_square*M2_M1_square_inverse)**0.5	

	!write(*,*) 'Ebv_vector:', Ebv_vector(1:3), Ebv_vector(N_bin_all_nodes-3:N_bin_all_nodes)
	!write(*,*) 'd_perpendicular_square:', d_perpendicular_square(1:3), d_perpendicular_square(N_bin_all_nodes-2:N_bin_all_nodes)
	 
        do ff=1,number_filters  !Now we want to compute the reddening of the M0 points, to get the M0' ones.
	 M0_prime(:,ff) = M0(:,ff) + A_lambda_filters_selected(ff) * Rv*Ebv_vector(:)
        enddo

	!write(*,*) 'M0_prime(1,:):', M0_prime(1,:)
	!write(*,*) 'M0_prime(2,:):', M0_prime(2,:)
	!write(*,*) 'M0_prime(N_bin_all_nodes,:):', M0_prime(N_bin_all_nodes,:)
	!write(*,*)
	
	!Now we want to get the distances between M0' and the M1 point (i.e. the coordinates of M0' in the system of M1).  
        do ff=1,number_filters
	 M1_M0_prime(:,ff) = abs(M0_prime(:,ff) - M1(ff))
        enddo

	!write(*,*) 'M1_M0_prime(1,:):', M1_M0_prime(1,:)
	!write(*,*) 'M1_M0_prime(2,:):', M1_M0_prime(2,:)
	!write(*,*) 'M1_M0_prime(N_bin_all_nodes,:):', M1_M0_prime(N_bin_all_nodes,:)
	!write(*,*)
	!read(*,*)




	!# -----------------------------
	!# Selection of models in the OB
	!# -----------------------------
	!#Traditional OB
	!selection = ne.evaluate("d_perpendicular < 3*sigma_magnitude")
	!Grid_completed_selection = Grid_completed[selection,:]
	counting(list) = 0
	OB_size(list) = 3
	sigma_factor = 3	!Indicates the size of the OB, in sigma units
	ID_models(:) = 0

	!If we want to explore all the models of the grid
	!counting(list) = N_bin_all_nodes
	!OB_size(list) = 7 !Means all nodes
	!If we want to explore an OB in place of all the models of the grid
	do

	 !!!! HERE IT COULD BE THAT I SHOULD PUT counting(list) = 0 : if the OB> 3, it should be
	 !!!! reinitialized, because we cannot take 2 times one model which was also in OB=3!!!!
 
	 do ii = 1,N_bin_all_nodes
	  in_box=0 !1
	 
	  !HERE PUT THE K FACTOR SELECTION,TO EXCLUDE MODELS OUT OF E(B-V)=[0,1], out of [0,k_max]
	  if (k(ii) >= 0 .and. k(ii)<0.5) then
	   do ff = 1,number_filters
	    !if (M1_M0_prime(ii,ff)<100000*sigma_filter(list,ff)) then	!General case
	    if (M1_M0_prime(ii,ff)<sigma_factor*sigma_filter(list,ff)) then	!General case
	    !if (abs(M1_M0(ii,ff))<sigma_factor*sigma_filter(list,ff)) then	!IF WE DO NOT WANT EXTINCTION!!!!!!!
	     in_box=1
	    else
	     in_box=0
	     exit
 	    endif
	   enddo
    in_box=1  !!!!!!!!!!!!INFINITE OB SIZE!!!!!!!!!!!!!!!! (means that we remove the OB, take all models of all nodes!!!)
	  endif
	
	  if (k(ii) < 0) then	!In that case we look if M0 ITSELF is in OB
	   do ff = 1,number_filters
	    !if (abs(M1_M0(ii,ff))<100000*sigma_filter(list,ff)) then		!General case
	    if (abs(M1_M0(ii,ff))<sigma_factor*sigma_filter(list,ff)) then		!General case
	     in_box=1
	    else
	     in_box=0
	     exit
 	    endif
	   enddo
	  endif
	  at_least_one_model_in_OB = in_box

	
	  if (in_box==1) then
	     counting(list) = counting(list) + 1
	     ID_models(counting(list)) = ii
	     Grid_completed_selection(counting(list),:) = Grid_completed(ii,:)
	     if (k(ii) >= 0 ) then !Case for inspection of the whole grid    !.and. k(ii)<0.5) then !Classical case	 
	      Grid_completed_selection(counting(list),3) = Ebv_vector(ii) !sign(Ebv_vector(ii),k(ii)) !Ebv_vector(ii) 
	     else
	      Grid_completed_selection(counting(list),3) = 0. !sign(Ebv_vector(ii),k(ii)) !0. !Case where k<0. --> M0 is in OB, no extinction.
	     endif
	     Grid_completed_selection(counting(list),4+number_filters_GLOBAL+1) = d_perpendicular_square(ii) !**0.5
	     Grid_completed_selection(counting(list),4+number_filters_GLOBAL+2) = d_perpendicular_square(ii)**(-1)

	     !Grid_completed_selection(counting(list),4+number_filters_GLOBAL+2+1:4+number_filters_GLOBAL+2+number_filters_GLOBAL) = &
	!&    + M1_M0_prime(ii,1:number_filters_GLOBAL) !Here add the M1-M0_prime table in Grid_completed_selection  !V101


	     !Here copy of M1_M0_prime into Grid_completed_selection
	     ff=0                                                 !#V105
	     do ff_GLOBAL=1,number_filters_GLOBAL                 !#V105
              if (M1_input_MagLim(list,ff_GLOBAL) == 1) then !mask[ff_GLOBAL]:  #proba built using filters with exact measurements, not Mag limits
               ff=ff+1  !In python we use after this ff_index = max(0,ff-1)  !#V105
	       Grid_completed_selection(counting(list),4+number_filters_GLOBAL+2+1:4+number_filters_GLOBAL+2+number_filters) = &
	       &    + M1_M0_prime(ii,1:number_filters) !V105       
	      endif
	     enddo



	     !Determination if there is at least one model of the node in the OB
             !age_int = nint(Grid_completed_selection(counting(list),1)*100)
             !mass_int = nint(Grid_completed_selection(counting(list),2)*100)
	     aa  = nint(20*(Grid_completed_selection(counting(list),1)-6.60)+1)
	     mm  = nint(20*(Grid_completed_selection(counting(list),2)-2.00)+1)
	     Ext = nint(50*max(Grid_completed_selection(counting(list),3),0.)) + 1
	     !Ext = nint(100*Grid_completed_selection(counting(list),3)) + 1
	     if (at_least_one_model_in_OB_array(aa,mm,ext) == 0 .and. at_least_one_model_in_OB == 1) then
	      at_least_one_model_in_OB_array(aa,mm,ext) = at_least_one_model_in_OB
	     endif

	  endif	
	 enddo

	 if (counting(list) > 1000) then        !We take no more than 1000 models to build the probability (true?)
	  exit
	 elseif (sigma_factor >= 6) then	!We do not explore further than 6 sigmas from observation
	  exit
	 else
	  sigma_factor = sigma_factor + 1
	  OB_size(list) = OB_size(list) + 1
	 endif
	enddo

        write(*,*) 'FLAG 1'
        read(*,*)


	counting_inverse = (counting(list)*1.)**(-1)
	write(*,*) 'Cluster  ', list, ' #in OB ',counting(list), ' OB_size = ', OB_size(list)
	!Here i could write a file containing all the models in the OB

	!write(*,*)'Ebv_vector(1)',Ebv_vector(1)
	!write(*,*)

	!write(*,*) 'Grid_completed_selection(1,:):', Grid_completed_selection(1,:)
	!write(*,*)
	!write(*,*) 'Grid_completed_selection(2,:):', Grid_completed_selection(2,:)
	!write(*,*)
	!write(*,*) 'Grid_completed_selection(counting(list),:):', Grid_completed_selection(counting(list),:)
	!write(*,*)
        !read(*,*)



	!# ------------------------------------
	!# Building the probabilities 
	!# ------------------------------------
	!The best thing to do now would be to create nodes files. I could launch separately the code on different Z. 
	!Then, with another code, i will read the results of all the Z (or only one, if desired) and produce final results
	!So, all what we have to do here is simply to put the results in a table age/mass/Ebv with their associated results:
	!sigma1, sigma2, sigma3(?), proba SG(?), proba CG and proba d2 of the whole node!

	!Writing of final solution 
	node_solution = 0.
	Proba_max_CG(list) = 0.
	Proba_max_d2(list) = 0.
        histo_age(:) = 0.	
        histo_mass(:)= 0.	
        histo_Ebv(:) = 0.	
        histo_Z(:)   = 0.
	zz_bis = 14-nint(0.5*zz)

	do ii = 1,counting(list)
         !age_int = nint(Grid_completed_selection(ii,1)*100)
         !mass_int = nint(Grid_completed_selection(ii,2)*100)
	 aa  = nint(20*(Grid_completed_selection(ii,1)-6.60)+1)
	 mm  = nint(20*(Grid_completed_selection(ii,2)-2.00)+1)
	 Ext = nint(50*max(Grid_completed_selection(ii,3),0.)) + 1  !NOTE: MAX NOT PRESENT IN SIMPLE V101 VERSION
	 !Ext = nint(100*Grid_completed_selection(ii,3)) + 1      HERE BE CAREFULL!! IS IT 100 OR 50????? 

	 !if (ii<100000) write(*,*) max(Grid_completed_selection(ii,3),0.), Ext




         
	 !proba_model=0.   !V101
	 !do ff = 1,number_filters_GLOBAL  !V101
	 ! proba_model = proba_model &
	!& + ( Grid_completed_selection(ii,4+number_filters_GLOBAL+2+ff) * sigma_filter_inverse_GLOBAL(list,ff) )**2	!General case
	 !enddo
	 !node_solution(aa,mm,Ext,1) = node_solution(aa,mm,Ext,1) &
	!& + exp(-0.5*proba_model) * counting_inverse	 ! counting_inverse: we normalize by the total number of points in the OB  !CG  !V101



         !Here building proba in V105 way
         proba_model=0.
         ff=0                                                 !#V105
	 do ff_GLOBAL=1,number_filters_GLOBAL                 !#V105
          if (M1_input_MagLim(list,ff_GLOBAL) == 1) then !mask[ff_GLOBAL]:  #proba built using filters with exact measurements, not Mag limits
           ff=ff+1                                            !#V105
           !# NOTE: in Python not ff but ff_index=max(0,ff-1) will be used, as C-like index start from 0
           !# In Fortran, I can just use ff
           !ff_index = max(0,ff-1) 

           proba_model = proba_model &
	& + ( Grid_completed_selection(ii,4+number_filters_GLOBAL+2+ff) * sigma_filter_inverse_GLOBAL(list,ff_GLOBAL) )**2	!General case  

           !if (ii<20) then
           ! write(*,*) proba_model, Grid_completed_selection(ii,4+number_filters_GLOBAL+2+ff)
           !endif
           !read(*,*)
                         
          endif
         enddo




         !# HERE USE THE STEP-FUNCTION!!!! Multiply the proba of the model by its associated step-function   #V105
         MagLim_Factor = 1.                                    !# Initialization of the magnitude-limit factor 
	 do ff_GLOBAL=1,number_filters_GLOBAL     !# For each filter we test:         
          if (M1_input_MagLim(list,ff_GLOBAL) == 0) then !if not mask[ff_GLOBAL]:                              # only for filters concerned by the magnitude-limit algorithm

           !# the ORIGINAL mag of the model...it should be REDDENED by the Ebv derived!
           xxx = Grid_completed_selection(ii,4+ff_GLOBAL) !+1?? #identical to M0_GLOBAL[selection,ff_GLOBAL][ii]               
           xxx = xxx + A_lambda_filters_selected_GLOBAL(ff_GLOBAL) * Rv * Grid_completed_selection(ii,3) !# the mag reddened (should I use np.max?)

           Amplitude=1.               !# the max of the step function (1.)
           sigma=sigma_filter_GLOBAL(list,ff_GLOBAL)   !# the sigma of the gaussian part of the step function
           !#mu=M1_input[list,ff_GLOBAL]                !# the magnitude-limit measured   
           !#mu=M1_input[list,ff_GLOBAL]  -  1.         !# the magnitude-limit measured   (IF - 1 IT MEANS TESTS OF THE ALGO!!!)
           mu=M1_input(ff_GLOBAL,list)  -  3.*sigma    !# the magnitude-limit measured   (IF - 3*sigma IT MEANS TESTS OF THE ALGO!!!)
           MagLim_Factor = MagLim_Factor * smooth_gaussian_step_scalar(xxx, 1., mu, sigma) !# building of the magnitude-limit factor
          endif
         enddo

	 !node_solution(aa,mm,Ext,1) = node_solution(aa,mm,Ext,1) &
	!& + exp(-0.5*proba_model) * counting_inverse	 ! counting_inverse: we normalize by the total number of points in the OB  !CG  !V101
	 node_solution(aa,mm,Ext,1) = node_solution(aa,mm,Ext,1) &
	& + exp(-0.5*proba_model) * counting_inverse !* MagLim_Factor  !V105




	 !if (ii<10) write(*,*)proba_model, exp(-0.5*proba_model), counting_inverse
	 !if (ii<10) write(*,*)aa,mm,Ext,node_solution(aa,mm,Ext,1) !write(*,*)proba_model
	 !if (Ext>150) write(*,*) ii

	 node_solution(aa,mm,Ext,2) = node_solution(aa,mm,Ext,2) &
	& + Grid_completed_selection(ii,4+number_filters_GLOBAL+2) * counting_inverse			!d2

	 if (node_solution(aa,mm,Ext,1) > Proba_max_CG(list) .and. Ext < 52) then !ATTENTION: LIMIT OF EXTINCTION HERE!
	  age_max_CG(list) = Grid_completed_selection(ii,1)
	  mass_max_CG(list) = Grid_completed_selection(ii,2)
	  Ebv_max_CG(list) = Grid_completed_selection(ii,3)
	  Proba_max_CG(list) = node_solution(aa,mm,Ext,1)
	 endif
	 !if (node_solution(age_int,mass_int,Ext,2) > Proba_max_d2(list) .and. Ext < 52) then
	 ! age_max_d2(list) = Grid_completed_selection(ii,1)
	 ! mass_max_d2(list) = Grid_completed_selection(ii,2)
	 ! Ebv_max_d2(list) = Grid_completed_selection(ii,3)
	 ! Proba_max_d2(list) = node_solution(age_int,mass_int,Ext,2)
	 !endif

	 !1D histograms!
	 histo_age(aa)   = histo_age(aa)   + exp(-0.5*proba_model)
	 histo_mass(mm)  = histo_mass(mm)  + exp(-0.5*proba_model) 
	 histo_Ebv(Ext)  = histo_Ebv(Ext)  + exp(-0.5*proba_model) 
	 histo_Z(zz_bis) = histo_Z(zz_bis) + exp(-0.5*proba_model) 

	enddo

	!write(*,*)'age, mass, Ebv, P:', age_max_CG(list), mass_max_CG(list), Ebv_max_CG(list), Proba_max_CG(list)
	!read(*,*)
	

	!Option: output the ID and parameters of models located in the OB. Slows down the code... 
	WRITE(jj_char, '(i10)' ) Cluster_ID(list)
	!OPEN(unit = 41,file=trim(file_out_cluster)//'Cluster_'//trim(adjustl(jj_char))//'_Z'//Z_indice_selected//'_V101_models.dat')
	!do ii = 1,counting(list)
        ! if (nint(Grid_completed_selection(ii,1)*100) ==  nint(age_max_CG(list)*100) ) then
        !  if (nint(Grid_completed_selection(ii,2)*100) == nint(mass_max_CG(list)*100) ) then
        !   if (nint(50*Grid_completed_selection(ii,3))  == nint(50*Ebv_max_CG(list)) ) then
	!    write(41,*)ID_models(ii), mod (ID_models(ii), 1000), Grid_completed_selection(ii,1), &
	!& Grid_completed_selection(ii,2), Grid_completed_selection(ii,3)
	!   endif
	!  endif
	! endif
	!enddo
 	!close(41)

	!# ----------------------------------------------
	!Writing of node file for each individual cluster  (takes a bit more time) OLD
	!# ----------------------------------------------
	!file_out_cluster_node=trim(file_out_cluster)//'node_files/'
	!OPEN(unit = 40,file=trim(file_out_cluster_node)//'Cluster_'//trim(adjustl(jj_char))//'_node_Z'//Z_indice_selected//'_V101.dat')
	!!OPEN(unit = 40,file=trim(file_out_cluster)//'_'//trim(adjustl(jj_char))//'_node_Z'//Z_indice_selected//'.bin', form='UNFORMATTED')
 	!do age_int = 650, 1200
 	! do mass_int = 200, 600
 	!  do Ext = 1,51 !Ext_limit1,Ext_limit2
	!   aa  = nint(20*(age_int/100.-6.60)+1)
	!   mm  = nint(20*(mass_int/100.-2.00)+1)
	!   !if (node_solution(age_int,mass_int,Ext,1) > 0.) then
	!   if (node_solution(age_int,mass_int,Ext,1) > 1e-43) then
 	!    write(40,'(i5,i5,i5,E12.4,i5,i5)') &
 	!    !write(40) &
	!& age_int, mass_int, Ext, &
	!& node_solution(age_int,mass_int,Ext,1), &
	!!& node_solution(age_int,mass_int,Ext,2), &
	!& at_least_one_model_in_OB_array(aa,mm,Ext)
	!   endif
 	!  enddo
 	! enddo
 	!enddo
 	!close(40)

	!# ----------------------------------------------
	!Writing of node file for each individual cluster  (takes a bit more time)
	!# ----------------------------------------------
	!file_out_cluster_node=trim(file_out_cluster)//'node_files/'
	!OPEN(unit = 40,file=trim(file_out_cluster_node)//'Cluster_'//trim(adjustl(jj_char))//'_node_Z'//Z_indice_selected//'.dat')
	!write(40,*)'#aa  mm  Ext Proba'
	!OPEN(unit = 40,file=trim(file_out_cluster)//'_'//trim(adjustl(jj_char))//'_node_Z'//Z_indice_selected//'.bin', form='UNFORMATTED')
 	!do aa = 1,71 !650, 1200
 	! do mm = 1,61 !200, 600
 	!  do Ext = 1,101 !Ext_limit1,Ext_limit2
	!   if (node_solution(aa,mm,Ext,1) > 0.) then
 	!    write(40,'(i4,i4,i4,E12.3,E12.3,i4)') &
 	!    !write(40) &
	!& aa,mm, Ext, &
	!& node_solution(aa,mm,Ext,1) !, &
	!!& node_solution(age_int,mass_int,Ext,2), &
	!!& nint(node_solution(age_int,mass_int,Ext,3))
	!   endif
 	!  enddo
 	! enddo
 	!enddo
 	!close(40)


	!# --------------------------------------------------
	!Writing of 1D histo file for each individual cluster 
	!# --------------------------------------------------
	!file_out_cluster_histo=trim(file_out_cluster)//'histo_files/'
	!OPEN(unit = 42,file=trim(file_out_cluster_histo)//'Cluster_'//trim(adjustl(jj_char))//'_histo1D_Z'//Z_indice_selected//'_V101.dat')
 	!do Ext = 1,101
	! write(42,'(E12.4,E12.4,E12.4,E12.4)') histo_age(Ext), histo_mass(Ext), histo_Ebv(Ext), histo_Z(Ext)
 	!enddo
 	!close(42)

        deALLOCATE(M0,M0_prime,M1,M2,M1_M0,M1_M0_prime,M2_M1)
        deALLOCATE(A_lambda_filters_selected)
        deALLOCATE(sigma_filter,sigma_filter_inverse)	

 ENDDO


 !# ----------------------------------------------
 !Writing of solutions for all clusters (for 1Z)
 !# ----------------------------------------------
 file_out_cluster_f90 = trim(file_out_cluster)
 file_out_cluster = trim(file_out_cluster)//'file_out_cluster'
 file_out_cluster_f90 = trim(file_out_cluster_f90)//'All_clusters_parameters_results_f90_V100'
 file_out_cluster_f90 = trim(file_out_cluster_f90)//'_Z'//Z_indice_selected
 open(unit=41,file=file_out_cluster_f90)
 !write(41,*)'#   age3 mas3 Ebv3  Proba3       age4 mas4 Ebv4  Proba4         count    OB'
 write(41,*)'# ID   age3 mas3 Ebv3  Proba3         count    OB'
 do list = number_begin,number_end
  !write(41,'(i5,F7.2,F5.2,F5.2,E12.4,F7.2,F5.2,F5.2,E12.4,i10,i5)') &
  write(41,'(i5,F7.2,F5.2,F5.2,E12.4,i10,i5)') &
	& Cluster_ID(list), &
	& age_max_CG(list),mass_max_CG(list),Ebv_max_CG(list),Proba_max_CG(list), &
	!& age_max_d2(list),mass_max_d2(list),Ebv_max_d2(list),Proba_max_d2(list), &
	& counting(list), OB_size(list)
 enddo
 close(41)



 deALLOCATE(Cluster_ID)
 deALLOCATE(Grid_completed)
 deALLOCATE(M0_GLOBAL)
 deALLOCATE(M1_input)
 !deALLOCATE(M1,M2)
 !deALLOCATE(M1_M0,M1_M0_prime)
 !deALLOCATE(M2_M1)
 deALLOCATE(d_direct_square)
 deALLOCATE(d_parallel_square)
 deALLOCATE(d_perpendicular_square)
 deALLOCATE(d_perpendicular)
 deALLOCATE(Ebv_vector)
 deALLOCATE(Grid_completed_selection)
 deALLOCATE(age_max_CG,mass_max_CG)
 deALLOCATE(Ebv_max_CG,Proba_max_CG)
 deALLOCATE(age_max_d2,mass_max_d2)
 deALLOCATE(Ebv_max_d2,Proba_max_d2)
 deALLOCATE(k,counting)
 deALLOCATE(OB_size)



 CALL system('date')
 WRITE(*,*)'Computation completed' 
 end program
