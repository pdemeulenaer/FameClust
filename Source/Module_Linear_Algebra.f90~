 
Module Linear_algebra_module
	
 contains 



 !#####################################################################
 real function function_determinant(N,mat_simple_precision)
 implicit none

 !THIS FUNCTION COMPUTES THE DETERMINANT OF SIMPLE-PRECISION MATRICES

 integer, intent(in) :: N
 real(4), dimension(N,N), intent(in) :: mat_simple_precision
 real(8), dimension(N,N) :: mat
 real(8) :: det, sgn
 integer, dimension(N) :: ipiv
 integer :: i, info

 mat = dble(mat_simple_precision)

 ipiv=0

 !call sgetrf(N, N, mat, N, ipiv, info) !Simple precision
 call dgetrf(N, N, mat, N, ipiv, info)  !Double precision

 if (info>0) then
  write(*,*) 'problem, info is ', info 
  read(*,*)
 endif

 det=1
 do i=1, N
    det = det*mat(i,i)
 end do

 if (isnan(det)) stop '1: det is a NaN'

 sgn=1
 do i=1, N
    if(ipiv(i)/=i)then
       sgn=-sgn
    end if
 end do
 det=sgn*det

 if (isnan(det)) stop '2: det is a NaN'

 function_determinant = real(det)

 return
 end function 
 !#####################################################################







 !#####################################################################
 SUBROUTINE Matrix_inversion(M,A,A_inverted)

 !SUBROUTINE OF INVERSION OF MATRIX
 !IT LOADS SIMPLE PRECISION MATRIX, TRANSLATES IT IN DOUBLE,
 !DOES THE JOB IN DOUBLE AND GIVE BACK INVERTED MATRIX IN SIMPLE

 Implicit none

 integer,intent(in) :: M   
 real(4),dimension(M,M),intent(in) :: A
 real(4),dimension(M,M),intent(out) :: A_inverted
 real(8),dimension(M,M) :: mat
 real(8),dimension(M) :: WORK
 integer,dimension(M) :: IPIV
 integer :: i,j,info,error

 mat = dble(A)

 call DGETRF(M,M,mat,M,IPIV,info)
 !if(info .eq. 0) then
 !  write(*,*)"succeded"
 !else
 ! write(*,*)"failed"
 !end if

 call DGETRI(M,mat,M,IPIV,WORK,M,info)
 !if(info .eq. 0) then
 !  write(*,*)"succeded"
 !else
 ! write(*,*)"failed"
 !end if

 A_inverted = real(mat)

 return

 END SUBROUTINE
 !#####################################################################




 !#####################################################################
 subroutine blas_multiplication_gmm(comp_number,normalization_here_all,x_mu_all,&
      & cov_inv_all,bidu1,bidu2,proba_node_3D_all,max_proba_position_gcc)


  integer,intent(in) :: comp_number
  real*4, dimension(71,101,10),intent(in) :: normalization_here_all
  real*4, dimension(121,71,101,10,6),intent(in) :: x_mu_all
  real*4, dimension(71,101,10,6,6),intent(in) :: cov_inv_all
  integer,intent(in) :: bidu1,bidu2
  !integer :: E_mini,E_maxi

  real*4, dimension(71,101,121),intent(out) :: proba_node_3D_all
  integer, dimension(3),intent(out) :: max_proba_position_gcc



    real*8 :: cov_inv(6,6), x_mu(6), zero_matrix(6)
    integer :: ii,ll,mm,aa,Ext,kk
    real*4, dimension(comp_number) :: proba_component
    real*4 :: resultat
    real*4 :: Ebv

    !allocate(cov_inv(6,6),x_mu(6),zero_matrix(6))
    !write(*,*) E_mini,E_maxi
    !write(*,*) bidu1,bidu2
    !read(*,*)

    do mm = 1,101
     do aa = 1,71

      !do Ext = bidu1,bidu2 !Ext_minimum,Ext_maximum !1,121
      do Ext = bidu1,bidu2 !E_mini,E_maxi !1,121
	  Ebv = (Ext-1)*0.01D0
	  proba_component(:)=0.D0 
	  do ii = 1,comp_number

	   cov_inv(:,:) = dble(cov_inv_all(aa,mm,ii,:,:))
	   x_mu(:) = dble(x_mu_all(Ext,aa,mm,ii,:))
	   zero_matrix(:) = 0.D0 !initial allocation

	   !'T' means transposed (vector before matrix: xt*M; 'N' means normal: M*x)
	   CALL DGEMV('T', size(cov_inv,1), size(cov_inv,2), 1.D0, cov_inv, size(cov_inv,1), x_mu, 1, 0.D0, zero_matrix, 1)  
	   resultat = 0.D0
	   do kk = 1,size(cov_inv,1)
	    resultat = resultat + zero_matrix(kk)*x_mu(kk)
	   enddo

	   proba_component(ii) = normalization_here_all(aa,mm,ii)*exp(-0.5*real(resultat))
	   proba_node_3d_all(aa,mm,Ext) = proba_node_3d_all(aa,mm,Ext) + proba_component(ii)

	  enddo
      enddo
     enddo
    enddo 

    !deallocate(cov_inv,x_mu,zero_matrix)

    !max_proba_gcc = MAXVAL(proba_node_3d_all)
    max_proba_position_gcc = MAXLOC(proba_node_3d_all)
    !print*, MAXVAL(proba_node_3d_all), MAXLOC(proba_node_3d_all)
 end subroutine blas_multiplication_gmm
 !#####################################################################







END MODULE Linear_algebra_module

