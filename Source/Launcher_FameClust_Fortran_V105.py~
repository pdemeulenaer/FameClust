# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# !											     !
# !											     !
# !		Python version of FameClust 10.5: LAUNCHER SCRIPT!!!     		     !	
# !		(Finding of Age Mass and Extinction of star Clusters)			     !
# !		Philippe de Meulenaer, PhD in Astrophysics               		     !
# !		Astronomical Observatory, Vilnius University				     !
# !											     !
# !											     !
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# !
# ! Marie je te confie cela...
# !
# ! Last update : 18 January 2016
# ! This program is built directly from the FameClust_python_V101.py version. The difference is the presence of the MagLim algorithm: filters which are just limit of magnitude will be treated in a convenient way (see below)

# This program is the launch script of the FORTRAN version of the FameClust algorithm (V10.5).
# python Launcher_FameClust_Fortran_V105.py InputFameClustNEW_GALEX_UBVRI_Z01900_M400 1 10 n00

# The idea is to modify the input file containing the parameters, as well as the photometry file.
# - The input parameter file will contain the name of the new photometry file. 
#   The input parameter file will be named as the old one with the extent "_temp"
# - The photometry file will contain the photometry in FameClust format, i.e.:
#     The ID, age,mass,Ebv,Z, photometry block, the uncertainty block, and the MagLim block.    
#   The photometry file will named as the old one with the extension "_temp"
# Question: should I remove automatically the _temp files? Maybe no, 
#           to check that these files are correctly built?

# --------------------------------------
# Declaration of imported python modules
# --------------------------------------

import numpy as np
import numexpr as ne
import scipy
import os
import math
import time
import random
from random import gauss
from pylab import *
import matplotlib.pyplot as plt
import sys
import subprocess as s
from scipy.optimize import curve_fit
import Lecture_module  # (Module located in /home/philippe/Desktop/Discrete_models_comparaison_jtao)
import os.path


def func(x, a, c, d):
    return a*np.exp(c*x)+d


# -------------------------
# Loading of the input file
# -------------------------

print
print 80*'-'
print
print 50*'-'
print 'Loading of InputFile'
print 50*'-'
print

#Reading of the command-line arguments
InputFile_Name = sys.argv[1]    # The name of input file is given during execution of the script
number_begin = int(sys.argv[2]) 
number_end = int(sys.argv[3])   
Z_indice_selected = sys.argv[4]

#Determination of the metallicity in the different needed formats: Z, [M/H] and zz (index)
Z_selected, zz = Lecture_module.Zindex_to_Z_and_zz(Z_indice_selected)
print Z_indice_selected, Z_selected, zz

#Input file is read in the function Reading_of_InputFile
number_filters_GLOBAL,        \
filters_selected_index,       \
Distance_modulus_host_galaxy, \
app_or_abs,                   \
file_observed_clusters,       \
number_cluster_observed,      \
choice_extinction,            \
choice_extinction_law,        \
path_file_out_cluster,        \
Grid_path1,                   \
Grid_path2,                   \
number_nodes_age,             \
number_nodes_mass,            \
number_models_per_node,       \
number_of_filters_in_grid,    \
File_information_filters_and_ExtCurve, \
Min_extinction,               \
Max_extinction,               \
choice_RealClusters_or_ArtificialTest = Lecture_module.Reading_of_InputFile(InputFile_Name)

print
print 50*'-'
print 'InputFile loaded'
print 50*'-'
print

#0=we do not remove the filters, 1=we remove the bad filters for some clusters,
#according to the "keep" flags in the original photometry file
choice_keep_or_remove_some_filters = 1

choice_F101_vs_F105 = 1 #1==F101, 2==F105 

#WE WILL BUILD A NEW .fmct FILE ONLY IF NOT PRESENT IN FOLDER!! 
#ERASE THE OLD ONE IF YOU WANT TO CREATE A NEW ONE!! 
file_fmct = path_file_out_cluster+'{0}.fmct'.format(file_observed_clusters)
if not bool(os.path.isfile(file_fmct)) : 


 # -----------------------------------------------------------------------------------------
 #Loading of the observations
 # -----------------------------------------------------------------------------------------
 print
 print 50*'-'
 print 'Loading of the observation'
 print 50*'-'
 print

 #NEW WAY OF READING THE PHOTOMETRY: SEARCHING AND USING THE NAMES OF FILTERS
 data_input = np.genfromtxt(path_file_out_cluster+file_observed_clusters, comments='#',names=True)
 FameClust_photometry_array = np.zeros((number_cluster_observed, 5+52+52+number_filters_GLOBAL)) + 99.99
 FameClust_photometry_array[:,0] = data_input['ID'] #Copy of the IDs


 if choice_RealClusters_or_ArtificialTest == 2: #IF REAL CLUSTERS

	 #CREATING THE MAGLIM ARRAY (Need to find this in the photometry file)
	 MagLim_array   = np.zeros((number_cluster_observed, number_filters_GLOBAL)) + 1
	 keepFlag_array = np.zeros((number_cluster_observed, number_filters_GLOBAL)) + 1

         #Here the strategy is to read the whole header of the file (reopen the file in different way) 
         #and check if the the l_F275W and others are present in the header. If yes, then read the 
         #associated columns and put them in the MagLim_array array. 
         #NB:Do the same for the flags "keep" (in the case we want to remove some filters for some clusters)
         file_header = open(path_file_out_cluster+file_observed_clusters, 'r')
         with open(path_file_out_cluster+file_observed_clusters, 'r') as f:
          first_line = f.readline().rstrip()
          first_line_splitted = first_line.split()
	 for ff in range(0,number_filters_GLOBAL):             #For each filter
	  filter_name = Lecture_module.FilterIndex_to_FilterName(filters_selected_index[ff])
          filter_MagLim_name = 'l_'+filter_name
          filter_keepFlag_name = 'keep'+filter_name
          for header_item in first_line_splitted:
           if filter_MagLim_name==header_item: 
            print 'Found : ', filter_MagLim_name
            MagLim_array[:,ff] = data_input[filter_MagLim_name]
           if filter_keepFlag_name==header_item: 
            print 'Found : ', filter_keepFlag_name
            keepFlag_array[:,ff] = data_input[filter_keepFlag_name]
	 if choice_keep_or_remove_some_filters == 1: #In the case we remove some filters (following "keep" flags)
	  FameClust_photometry_array[:,5+52+52:5+52+52+number_filters_GLOBAL] = MagLim_array[:,:]*keepFlag_array[:,:]
	 if choice_keep_or_remove_some_filters == 0: #In the case we do not remove filters 
	  FameClust_photometry_array[:,5+52+52:5+52+52+number_filters_GLOBAL] = MagLim_array[:,:]
	  

	 #COPY OF RELEVANT PHOTOMETRY (only the few filters concerned)
	 for ff in range(0,number_filters_GLOBAL):             #For each filter
	  filter_name = Lecture_module.FilterIndex_to_FilterName(filters_selected_index[ff])
	  FameClust_photometry_array[:,filters_selected_index[ff]+4] = data_input[filter_name]

	 #Copy of REAL and MAGLIM uncertainties
	 for ff in range(0,number_filters_GLOBAL):             #For each filter
          for jj in range(0,number_cluster_observed):
	   filter_name = Lecture_module.FilterIndex_to_FilterName(filters_selected_index[ff])
           if MagLim_array[jj,ff] == 1: uncertainty_name = 'e_'+filter_name   #Copy of REAL uncertainties 	
           if MagLim_array[jj,ff] == 0: uncertainty_name = 'e_l_'+filter_name #Copy of MAGLIM uncertainties 
	   FameClust_photometry_array[jj,filters_selected_index[ff]+4+52] = data_input[uncertainty_name][jj]

           #IF F101 VERSION AND In the case we remove some filters (following "keep" flags):
	   if choice_F101_vs_F105 == 1 and choice_keep_or_remove_some_filters == 1: 
            if keepFlag_array[jj,ff] == 1: #Filter is kept
	     FameClust_photometry_array[jj,filters_selected_index[ff]+4+52] = data_input[uncertainty_name][jj]
            if keepFlag_array[jj,ff] == 0: #Filter is removed
	     FameClust_photometry_array[jj,filters_selected_index[ff]+4+52] = 99.99


 if choice_RealClusters_or_ArtificialTest == 1: #IF ARTIFICIAL TESTS
         #In this case the user has to specify HERE which filters will be used as MagLim
         #By default, all filters are used normally (initialized at 1)

	 #CREATING THE MAGLIM ARRAY
	 Filters_used_with_MagLim = [] #['F275W','F160W']
	 MagLim_array = np.zeros((number_cluster_observed, number_filters_GLOBAL)) + 1 
	 for ff in range(0,number_filters_GLOBAL):             #For each filter
	  for filter_name in Filters_used_with_MagLim:         #We search the index of the filter...
	   filter_name_index = Lecture_module.FilterName_to_FilterIndex(filter_name)   #...using this function
	   if filter_name_index == filters_selected_index[ff]: #When we find the index:
	    print filter_name_index, filter_name               #(we just print)
	    MagLim_array[:,ff] = MagLim_array[:,ff] * 0        #we adapt the MagLim array for that filter
	 print MagLim_array[0,0:number_filters_GLOBAL]
	 FameClust_photometry_array[:,5+52+52:5+52+52+number_filters_GLOBAL] = MagLim_array[:,:]

	 #COPY OF ALL PHOTOMETRY 
	 for ff in range(1,53):             #For each filter
	  filter_name = Lecture_module.FilterIndex_to_FilterName(ff)
	  FameClust_photometry_array[:,4+ff] = data_input[filter_name]

	 FameClust_photometry_array[:,1] = data_input['Age']                      
	 FameClust_photometry_array[:,2] = data_input['Mass'] 
	 FameClust_photometry_array[:,3] = data_input['Ext'] 
	 FameClust_photometry_array[:,4] = data_input['Z'] 

	 #AUTOMATIC UNCERTAINTIES
	 #filters_A_lambda = np.genfromtxt('Filters_information.dat',comments='#')
	 filters_A_lambda = np.genfromtxt(File_information_filters_and_ExtCurve,comments='#')
	 for ff in range(1,53):
	  FameClust_photometry_array[:,4+52+ff] = FameClust_photometry_array[:,4+52+ff]*0. + filters_A_lambda[ff-1,4]

 del data_input
 print 50*'-'
 print 'Observation loaded'
 print 50*'-'
 print





 # -----------------------------------------------------------------------------------------
 # CREATION OF THE .fmct FILE
 # -----------------------------------------------------------------------------------------

 outfile_FameClust_format = open(path_file_out_cluster+'{0}.fmct'.format(file_observed_clusters),'w')

 #Preparation of the header for MagLim array
 MagLim_array_header = '' 
 for ff in range(0,number_filters_GLOBAL):             #For each filter
  filter_name = Lecture_module.FilterIndex_to_FilterName(filters_selected_index[ff])
  MagLim_array_header = MagLim_array_header + '   l_{0}'.format(filter_name) #Creating the header

 #Here is the global header
 print >> outfile_FameClust_format, '#       ID   Age        Mass       Ext        Z          FUV        NUV        U          B          V          R          I          J          H          K           F275W      F336W      F475W      F814W      F110W      F160W     u_CFHT     g_CFHT     r_CFHT     i_CFHT     z_CFHT     u_SDSS     g_SDSS     r_SDSS     i_SDSS     z_SDSS     J_2MASS    H_2MASS    Ks_2MASS   a_BATC     b_BATC     c_BATC     d_BATC     e_BATC     f_BATC     g_BATC     h_BATC     i_BATC     j_BATC     k_BATC     m_BATC     n_BATC     o_BATC     p_BATC     t_BATC     IRAC36     IRAC45     IRAC85     IRAC80     mip24      mip70      mip160     e_FUV      e_NUV      e_U        e_B        e_V        e_R        e_I        e_J        e_H        e_K        e_F275W    e_F336W    e_F475W    e_F814W    e_F110W    e_F160W    e_u_CFHT   e_g_CFHT   e_r_CFHT   e_i_CFHT   e_z_CFHT   e_u_SDSS   e_g_SDSS   e_r_SDSS   e_i_SDSS   e_z_SDSS   e_J_2MASS  e_H_2MASS  e_Ks_2MASS e_a_BATC   e_b_BATC   e_c_BATC   e_d_BATC   e_e_BATC   e_f_BATC   e_g_BATC   e_h_BATC   e_i_BATC   e_j_BATC   e_k_BATC   e_m_BATC   e_n_BATC   e_o_BATC   e_p_BATC   e_t_BATC   e_IRAC36   e_IRAC45   e_IRAC58   e_IRAC80   e_mip24    e_mip70    e_mip160{0}'.format(MagLim_array_header)

 format_output = '%10d' + 4*' %10.5f' + 52*' %10.5f' + 52*' %10.5f' + number_filters_GLOBAL*'%10d'
 np.savetxt(outfile_FameClust_format,FameClust_photometry_array,fmt=format_output) #'%10.5f')
 outfile_FameClust_format.close()


 # -----------------------------------------------------------------------------------------
 # LAUNCH of the FORTRAN FameClust code
 # -----------------------------------------------------------------------------------------

print 'The Launch command will be: '
raw_input()
if choice_F101_vs_F105 == 1: #LAUNCHING F101 VERSION
 print 'time ./FameClust_V101_observation.exe {0} {1} {2} {3}'.format(InputFile_Name,number_begin,number_end,Z_indice_selected)
 print 'Waiting before launching the code (just push to start)'
 os.system('time ./FameClust_V101_observation.exe {0} {1} {2} {3}'.format(InputFile_Name,number_begin,number_end,Z_indice_selected))

if choice_F101_vs_F105 == 2: #LAUNCHING F105 VERSION
 print 'time ./FameClust_V105_observation.exe {0} {1} {2} {3}'.format(InputFile_Name,number_begin,number_end,Z_indice_selected)
 print 'Waiting before launching the code (just push to start)'
 os.system('time ./FameClust_V105_observation.exe {0} {1} {2} {3}'.format(InputFile_Name,number_begin,number_end,Z_indice_selected))





















'''  
#NOW THIS FUNCTION IS SITUATED IN THE MODULE Lecture_module
def Reading_of_InputFile(InputFile_Name):
	InputFile = open('/home/philippe/Desktop/Discrete_models_comparaison_jtao/SC_Parameters_20/'+InputFile_Name).readlines()
	my_list = []
	for line in InputFile:
	    item = str.split(line)
	    print item
	    if item[0][0] != '#':
	     #my_list.append(item[0])
             for item_of_item in item:
	      my_list.append(item_of_item)

	number_filters_GLOBAL = int(my_list[0])
	print 'Number of filters selected:                 ', number_filters_GLOBAL

	filters_selected_index = np.arange(number_filters_GLOBAL) 	#integer array containing the indexes of the selected filters 
	for ff in range(0,number_filters_GLOBAL):
	 filters_selected_index[ff] = int(my_list[ff+1])
	print 'Indexes of filters selected:               ', filters_selected_index

	Distance_modulus_host_galaxy = my_list[number_filters_GLOBAL+1]
	print 'Distance modulus of the host galaxy:        ', Distance_modulus_host_galaxy
	app_or_abs = int(my_list[number_filters_GLOBAL+2])
	print 'Apparent mags [1], Absolute mags [2]:       ', app_or_abs
	file_observed_clusters = my_list[number_filters_GLOBAL+3]
	print 'Input file of the observed clusters:        '
	print '    ',file_observed_clusters
	number_cluster_observed = int(my_list[number_filters_GLOBAL+4])
	print 'Number of observed clusters:                ',  number_cluster_observed	#[obsolete?] used with MagLim!
	choice_extinction = int(my_list[number_filters_GLOBAL+5])
	print 'Cluster(s) extincted [1], not extincted [2]:', choice_extinction
	choice_extinction_law = int(my_list[number_filters_GLOBAL+6])
	print 'Extinction law of MW [1], of LMC [2]:       ', choice_extinction_law
	path_file_out_cluster = my_list[number_filters_GLOBAL+7]
	print 'Path of output files for derived parameters:' 
	print '    ',path_file_out_cluster
        Grid_path1 = my_list[number_filters_GLOBAL+8]
        Grid_path2 = my_list[number_filters_GLOBAL+9]       
        print 'Path and name of the grid of models:'
        print Grid_path1
        print Grid_path2
        number_nodes_age,number_nodes_mass = int(my_list[number_filters_GLOBAL+10]),int(my_list[number_filters_GLOBAL+11])
        print 'Number of age nodes and of mass nodes:', number_nodes_age,number_nodes_mass
        number_models_per_node = int(my_list[number_filters_GLOBAL+12])
        print 'Number of models per node:', number_models_per_node
        number_of_filters_in_grid = int(my_list[number_filters_GLOBAL+13])
        print 'Number of filters available in the grid of models:', number_of_filters_in_grid
        File_information_filters_and_ExtCurve = my_list[number_filters_GLOBAL+14]
        print 'Name of the file containing infos of filters and extinction curve:', File_information_filters_and_ExtCurve
        Min_extinction, Max_extinction = float(my_list[number_filters_GLOBAL+15]),float(my_list[number_filters_GLOBAL+16])
        print 'Minimum and maximum extinction:',Min_extinction, Max_extinction
        choice_RealClusters_or_ArtificialTest = int(my_list[number_filters_GLOBAL+17])
        print 'Artificial test or real clusters studied (1/2):', choice_RealClusters_or_ArtificialTest

        return number_filters_GLOBAL,        \
               filters_selected_index,       \
               Distance_modulus_host_galaxy, \
               app_or_abs,                   \
               file_observed_clusters,       \
               number_cluster_observed,      \
               choice_extinction,            \
               choice_extinction_law,        \
               path_file_out_cluster,        \
               Grid_path1,                   \
               Grid_path2,                   \
               number_nodes_age,             \
               number_nodes_mass,            \
               number_models_per_node,       \
               number_of_filters_in_grid,    \
               File_information_filters_and_ExtCurve, \
               Min_extinction,               \
               Max_extinction,               \
               choice_RealClusters_or_ArtificialTest
'''






